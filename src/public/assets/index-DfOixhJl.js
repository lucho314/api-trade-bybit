var Wu = Object.defineProperty; var Vu = Object.getPrototypeOf; var Hu = Reflect.get; var Ka = e => { throw TypeError(e) }; var Uu = (e, t, r) => t in e ? Wu(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r; var k = (e, t, r) => Uu(e, typeof t != "symbol" ? t + "" : t, r), as = (e, t, r) => t.has(e) || Ka("Cannot " + r); var c = (e, t, r) => (as(e, t, "read from private field"), r ? r.call(e) : t.get(e)), y = (e, t, r) => t.has(e) ? Ka("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), V = (e, t, r, n) => (as(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), it = (e, t, r) => (as(e, t, "access private method"), r); var Ga = (e, t, r) => Hu(Vu(e), r, t); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const o of document.querySelectorAll('link[rel="modulepreload"]')) n(o); new MutationObserver(o => { for (const i of o) if (i.type === "childList") for (const s of i.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && n(s) }).observe(document, { childList: !0, subtree: !0 }); function r(o) { const i = {}; return o.integrity && (i.integrity = o.integrity), o.referrerPolicy && (i.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? i.credentials = "include" : o.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i } function n(o) { if (o.ep) return; o.ep = !0; const i = r(o); fetch(o.href, i) } })(); const qa = !1; var Yi = Array.isArray, ju = Array.prototype.indexOf, ta = Array.from, Ku = Object.defineProperty, je = Object.getOwnPropertyDescriptor, Ul = Object.getOwnPropertyDescriptors, Gu = Object.prototype, qu = Array.prototype, ea = Object.getPrototypeOf, Ya = Object.isExtensible; function un(e) { return typeof e == "function" } const et = () => { }; function Yu(e) { return e() } function di(e) { for (var t = 0; t < e.length; t++)e[t]() } function Xu(e, t) { if (Array.isArray(e)) return e; if (!(Symbol.iterator in e)) return Array.from(e); const r = []; for (const n of e) if (r.push(n), r.length === t) break; return r } const Xt = 2, jl = 4, Xi = 8, ra = 16, Ce = 32, fr = 64, na = 128, Bt = 256, fi = 512, Gt = 1024, Pe = 2048, hr = 4096, Se = 8192, oa = 16384, Kl = 32768, Yr = 65536, Zu = 1 << 17, Ju = 1 << 19, Gl = 1 << 20, bs = 1 << 21, oe = Symbol("$state"), ql = Symbol("legacy props"), Qu = Symbol(""); function Yl(e) { return e === this.v } function Xl(e, t) { return e != e ? t == t : e !== t || e !== null && typeof e == "object" || typeof e == "function" } function $u(e, t) { return e !== t } function ia(e) { return !Xl(e, this.v) } function td(e) { throw new Error("https://svelte.dev/e/effect_in_teardown") } function ed() { throw new Error("https://svelte.dev/e/effect_in_unowned_derived") } function rd(e) { throw new Error("https://svelte.dev/e/effect_orphan") } function nd() { throw new Error("https://svelte.dev/e/effect_update_depth_exceeded") } function od(e) { throw new Error("https://svelte.dev/e/props_invalid_value") } function id() { throw new Error("https://svelte.dev/e/state_descriptors_fixed") } function sd() { throw new Error("https://svelte.dev/e/state_prototype_fixed") } function ad() { throw new Error("https://svelte.dev/e/state_unsafe_mutation") } let Xr = !1, ld = !1; function cd() { Xr = !0 } const sa = 1, aa = 2, Zl = 4, ud = 8, dd = 16, fd = 1, hd = 2, gd = 4, pd = 8, vd = 16, md = 1, bd = 2, It = Symbol(), wd = "http://www.w3.org/1999/xhtml", yd = "http://www.w3.org/2000/svg", Jl = "@attach"; function Ql(e) { throw new Error("https://svelte.dev/e/lifecycle_outside_component") } let lt = null; function Xa(e) { lt = e } function Za(e) { return Zi().get(e) } function _d(e, t) { return Zi().set(e, t), t } function xd(e) { return Zi().has(e) } function Sd() { return Zi() } function Z(e, t = !1, r) { var n = lt = { p: lt, c: null, d: !1, e: null, m: !1, s: e, x: null, l: null }; Xr && !t && (lt.l = { s: null, u: null, r1: [], r2: jt(!1) }), ac(() => { n.d = !0 }) } function J(e) { const t = lt; if (t !== null) { const s = t.e; if (s !== null) { var r = st, n = ot; t.e = null; try { for (var o = 0; o < s.length; o++) { var i = s[o]; qe(i.effect), se(i.reaction), Yo(i.fn) } } finally { qe(r), se(n) } } lt = t.p, t.m = !0 } return {} } function Zr() { return !Xr || lt !== null && lt.l === null } function Zi(e) { return lt === null && Ql(), lt.c ?? (lt.c = new Map(Ad(lt) || void 0)) } function Ad(e) { let t = e.p; for (; t !== null;) { const r = t.c; if (r !== null) return r; t = t.p } return null } function Kt(e) { if (typeof e != "object" || e === null || oe in e) return e; const t = ea(e); if (t !== Gu && t !== qu) return e; var r = new Map, n = Yi(e), o = X(0), i = ot, s = a => { var l = ot; se(i); var u = a(); return se(l), u }; return n && r.set("length", X(e.length)), new Proxy(e, { defineProperty(a, l, u) { (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && id(); var f = r.get(l); return f === void 0 ? f = s(() => { var d = X(u.value); return r.set(l, d), d }) : N(f, u.value, !0), !0 }, deleteProperty(a, l) { var u = r.get(l); if (u === void 0) { if (l in a) { const h = s(() => X(It)); r.set(l, h), ls(o) } } else { if (n && typeof l == "string") { var f = r.get("length"), d = Number(l); Number.isInteger(d) && d < f.v && N(f, d) } N(u, It), ls(o) } return !0 }, get(a, l, u) { var p; if (l === oe) return e; var f = r.get(l), d = l in a; if (f === void 0 && (!d || (p = je(a, l)) != null && p.writable) && (f = s(() => { var v = Kt(d ? a[l] : It), w = X(v); return w }), r.set(l, f)), f !== void 0) { var h = g(f); return h === It ? void 0 : h } return Reflect.get(a, l, u) }, getOwnPropertyDescriptor(a, l) { var u = Reflect.getOwnPropertyDescriptor(a, l); if (u && "value" in u) { var f = r.get(l); f && (u.value = g(f)) } else if (u === void 0) { var d = r.get(l), h = d == null ? void 0 : d.v; if (d !== void 0 && h !== It) return { enumerable: !0, configurable: !0, value: h, writable: !0 } } return u }, has(a, l) { var h; if (l === oe) return !0; var u = r.get(l), f = u !== void 0 && u.v !== It || Reflect.has(a, l); if (u !== void 0 || st !== null && (!f || (h = je(a, l)) != null && h.writable)) { u === void 0 && (u = s(() => { var p = f ? Kt(a[l]) : It, v = X(p); return v }), r.set(l, u)); var d = g(u); if (d === It) return !1 } return f }, set(a, l, u, f) { var b; var d = r.get(l), h = l in a; if (n && l === "length") for (var p = u; p < d.v; p += 1) { var v = r.get(p + ""); v !== void 0 ? N(v, It) : p in a && (v = s(() => X(It)), r.set(p + "", v)) } if (d === void 0) (!h || (b = je(a, l)) != null && b.writable) && (d = s(() => X(void 0)), N(d, Kt(u)), r.set(l, d)); else { h = d.v !== It; var w = s(() => Kt(u)); N(d, w) } var _ = Reflect.getOwnPropertyDescriptor(a, l); if (_ != null && _.set && _.set.call(f, u), !h) { if (n && typeof l == "string") { var S = r.get("length"), x = Number(l); Number.isInteger(x) && x >= S.v && N(S, x + 1) } ls(o) } return !0 }, ownKeys(a) { g(o); var l = Reflect.ownKeys(a).filter(d => { var h = r.get(d); return h === void 0 || h.v !== It }); for (var [u, f] of r) f.v !== It && !(u in a) && l.push(u); return l }, setPrototypeOf() { sd() } }) } function ls(e, t = 1) { N(e, e.v + t) } function Ja(e) { try { if (e !== null && typeof e == "object" && oe in e) return e[oe] } catch { } return e } function Pd(e, t) { return Object.is(Ja(e), Ja(t)) } function cr(e) { var t = Xt | Pe, r = ot !== null && (ot.f & Xt) !== 0 ? ot : null; return st === null || r !== null && (r.f & Bt) !== 0 ? t |= Bt : st.f |= Gl, { ctx: lt, deps: null, effects: null, equals: Yl, f: t, fn: e, reactions: null, rv: 0, v: null, wv: 0, parent: r ?? st } } function M(e) { const t = cr(e); return pc(t), t } function re(e) { const t = cr(e); return t.equals = ia, t } function $l(e) { var t = e.effects; if (t !== null) { e.effects = null; for (var r = 0; r < t.length; r += 1)Dt(t[r]) } } function Ed(e) { for (var t = e.parent; t !== null;) { if ((t.f & Xt) === 0) return t; t = t.parent } return null } function tc(e) { var t, r = st; qe(Ed(e)); try { $l(e), t = wc(e) } finally { qe(r) } return t } function ec(e) { var t = tc(e); if (e.equals(t) || (e.v = t, e.wv = mc()), !Jr) { var r = (Ue || (e.f & Bt) !== 0) && e.deps !== null ? hr : Gt; ae(e, r) } } const yn = new Map; function jt(e, t) { var r = { f: 0, v: e, reactions: null, equals: Yl, rv: 0, wv: 0 }; return r } function X(e, t) { const r = jt(e); return pc(r), r } function Ar(e, t = !1, r = !0) { var o; const n = jt(e); return t || (n.equals = ia), Xr && r && lt !== null && lt.l !== null && ((o = lt.l).s ?? (o.s = [])).push(n), n } function N(e, t, r = !1) { ot !== null && !qt && Zr() && (ot.f & (Xt | ra)) !== 0 && !(Pt != null && Pt[1].includes(e) && Pt[0] === ot) && ad(); let n = r ? Kt(t) : t; return ws(e, n) } function ws(e, t) { if (!e.equals(t)) { var r = e.v; Jr ? yn.set(e, t) : yn.set(e, r), e.v = t, (e.f & Xt) !== 0 && ((e.f & Pe) !== 0 && tc(e), ae(e, (e.f & Bt) === 0 ? Gt : hr)), e.wv = mc(), rc(e, Pe), Zr() && st !== null && (st.f & Gt) !== 0 && (st.f & (Ce | fr)) === 0 && (Vt === null ? Wd([e]) : Vt.push(e)) } return t } function rc(e, t) { var r = e.reactions; if (r !== null) for (var n = Zr(), o = r.length, i = 0; i < o; i++) { var s = r[i], a = s.f; (a & Pe) === 0 && (!n && s === st || (ae(s, t), (a & (Gt | Bt)) !== 0 && ((a & Xt) !== 0 ? rc(s, hr) : da(s)))) } } function Od() { console.warn("https://svelte.dev/e/select_multiple_invalid_value") } let Cd = !1; var Qa, nc, oc, ic; function Td() { if (Qa === void 0) { Qa = window, nc = /Firefox/.test(navigator.userAgent); var e = Element.prototype, t = Node.prototype, r = Text.prototype; oc = je(t, "firstChild").get, ic = je(t, "nextSibling").get, Ya(e) && (e.__click = void 0, e.__className = void 0, e.__attributes = null, e.__style = void 0, e.__e = void 0), Ya(r) && (r.__t = void 0) } } function qo(e = "") { return document.createTextNode(e) } function Ur(e) { return oc.call(e) } function Ji(e) { return ic.call(e) } function nt(e, t) { return Ur(e) } function F(e, t) { { var r = Ur(e); return r instanceof Comment && r.data === "" ? Ji(r) : r } } function G(e, t = 1, r = !1) { let n = e; for (; t--;)n = Ji(n); return n } function kd(e) { e.textContent = "" } function sc(e) { st === null && ot === null && rd(), ot !== null && (ot.f & Bt) !== 0 && st === null && ed(), Jr && td() } function Nd(e, t) { var r = t.last; r === null ? t.last = t.first = e : (r.next = e, e.prev = r, t.last = e) } function gr(e, t, r, n = !0) { var o = st, i = { ctx: lt, deps: null, nodes_start: null, nodes_end: null, f: e | Pe, first: null, fn: t, last: null, next: null, parent: o, prev: null, teardown: null, transitions: null, wv: 0 }; if (r) try { ua(i), i.f |= Kl } catch (l) { throw Dt(i), l } else t !== null && da(i); var s = r && i.deps === null && i.first === null && i.nodes_start === null && i.teardown === null && (i.f & (Gl | na)) === 0; if (!s && n && (o !== null && Nd(i, o), ot !== null && (ot.f & Xt) !== 0)) { var a = ot; (a.effects ?? (a.effects = [])).push(i) } return i } function Id() { return ot !== null && !qt } function ac(e) { const t = gr(Xi, null, !1); return ae(t, Gt), t.teardown = e, t } function yt(e) { sc(); var t = st !== null && (st.f & Ce) !== 0 && lt !== null && !lt.m; if (t) { var r = lt; (r.e ?? (r.e = [])).push({ fn: e, effect: st, reaction: ot }) } else { var n = Yo(e); return n } } function la(e) { return sc(), Qi(e) } function Rd(e) { const t = gr(fr, e, !0); return () => { Dt(t) } } function Md(e) { const t = gr(fr, e, !0); return (r = {}) => new Promise(n => { r.outro ? ur(t, () => { Dt(t), n(void 0) }) : (Dt(t), n(void 0)) }) } function Yo(e) { return gr(jl, e, !1) } function Qi(e) { return gr(Xi, e, !0) } function Nt(e, t = [], r = cr) { const n = t.map(r); return Te(() => e(...n.map(g))) } function Te(e, t = 0) { return gr(Xi | ra | t, e, !0) } function Zt(e, t = !0) { return gr(Xi | Ce, e, !0, t) } function lc(e) { var t = e.teardown; if (t !== null) { const r = Jr, n = ot; $a(!0), se(null); try { t.call(null) } finally { $a(r), se(n) } } } function cc(e, t = !1) { var r = e.first; for (e.first = e.last = null; r !== null;) { var n = r.next; (r.f & fr) !== 0 ? r.parent = null : Dt(r, t), r = n } } function Dd(e) { for (var t = e.first; t !== null;) { var r = t.next; (t.f & Ce) === 0 && Dt(t), t = r } } function Dt(e, t = !0) { var r = !1; (t || (e.f & Ju) !== 0) && e.nodes_start !== null && e.nodes_end !== null && (Fd(e.nodes_start, e.nodes_end), r = !0), cc(e, t && !r), gi(e, 0), ae(e, oa); var n = e.transitions; if (n !== null) for (const i of n) i.stop(); lc(e); var o = e.parent; o !== null && o.first !== null && uc(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes_start = e.nodes_end = null } function Fd(e, t) { for (; e !== null;) { var r = e === t ? null : Ji(e); e.remove(), e = r } } function uc(e) { var t = e.parent, r = e.prev, n = e.next; r !== null && (r.next = n), n !== null && (n.prev = r), t !== null && (t.first === e && (t.first = n), t.last === e && (t.last = r)) } function ur(e, t) { var r = []; ca(e, r, !0), dc(r, () => { Dt(e), t && t() }) } function dc(e, t) { var r = e.length; if (r > 0) { var n = () => --r || t(); for (var o of e) o.out(n) } else t() } function ca(e, t, r) { if ((e.f & Se) === 0) { if (e.f ^= Se, e.transitions !== null) for (const s of e.transitions) (s.is_global || r) && t.push(s); for (var n = e.first; n !== null;) { var o = n.next, i = (n.f & Yr) !== 0 || (n.f & Ce) !== 0; ca(n, t, i ? r : !1), n = o } } } function _n(e) { fc(e, !0) } function fc(e, t) { if ((e.f & Se) !== 0) { e.f ^= Se; for (var r = e.first; r !== null;) { var n = r.next, o = (r.f & Yr) !== 0 || (r.f & Ce) !== 0; fc(r, o ? t : !1), r = n } if (e.transitions !== null) for (const i of e.transitions) (i.is_global || t) && i.in() } } let xn = [], ys = []; function hc() { var e = xn; xn = [], di(e) } function Ld() { var e = ys; ys = [], di(e) } function $i(e) { xn.length === 0 && queueMicrotask(hc), xn.push(e) } function Bd() { xn.length > 0 && hc(), ys.length > 0 && Ld() } function zd(e) { var t = st; if ((t.f & Kl) === 0) { if ((t.f & na) === 0) throw e; t.fn(e) } else gc(e, t) } function gc(e, t) { for (; t !== null;) { if ((t.f & na) !== 0) try { t.fn(e); return } catch { } t = t.parent } throw e } let Sn = !1, An = null, lr = !1, Jr = !1; function $a(e) { Jr = e } let mn = []; let ot = null, qt = !1; function se(e) { ot = e } let st = null; function qe(e) { st = e } let Pt = null; function pc(e) { ot !== null && ot.f & bs && (Pt === null ? Pt = [ot, [e]] : Pt[1].push(e)) } let Rt = null, Ft = 0, Vt = null; function Wd(e) { Vt = e } let vc = 1, hi = 0, Ue = !1; function mc() { return ++vc } function ts(e) { var d; var t = e.f; if ((t & Pe) !== 0) return !0; if ((t & hr) !== 0) { var r = e.deps, n = (t & Bt) !== 0; if (r !== null) { var o, i, s = (t & fi) !== 0, a = n && st !== null && !Ue, l = r.length; if (s || a) { var u = e, f = u.parent; for (o = 0; o < l; o++)i = r[o], (s || !((d = i == null ? void 0 : i.reactions) != null && d.includes(u))) && (i.reactions ?? (i.reactions = [])).push(u); s && (u.f ^= fi), a && f !== null && (f.f & Bt) === 0 && (u.f ^= Bt) } for (o = 0; o < l; o++)if (i = r[o], ts(i) && ec(i), i.wv > e.wv) return !0 } (!n || st !== null && !Ue) && ae(e, Gt) } return !1 } function bc(e, t, r = !0) { var n = e.reactions; if (n !== null) for (var o = 0; o < n.length; o++) { var i = n[o]; Pt != null && Pt[1].includes(e) && Pt[0] === ot || ((i.f & Xt) !== 0 ? bc(i, t, !1) : t === i && (r ? ae(i, Pe) : (i.f & Gt) !== 0 && ae(i, hr), da(i))) } } function wc(e) { var p; var t = Rt, r = Ft, n = Vt, o = ot, i = Ue, s = Pt, a = lt, l = qt, u = e.f; Rt = null, Ft = 0, Vt = null, Ue = (u & Bt) !== 0 && (qt || !lr || ot === null), ot = (u & (Ce | fr)) === 0 ? e : null, Pt = null, Xa(e.ctx), qt = !1, hi++, e.f |= bs; try { var f = (0, e.fn)(), d = e.deps; if (Rt !== null) { var h; if (gi(e, Ft), d !== null && Ft > 0) for (d.length = Ft + Rt.length, h = 0; h < Rt.length; h++)d[Ft + h] = Rt[h]; else e.deps = d = Rt; if (!Ue) for (h = Ft; h < d.length; h++)((p = d[h]).reactions ?? (p.reactions = [])).push(e) } else d !== null && Ft < d.length && (gi(e, Ft), d.length = Ft); if (Zr() && Vt !== null && !qt && d !== null && (e.f & (Xt | hr | Pe)) === 0) for (h = 0; h < Vt.length; h++)bc(Vt[h], e); return o !== null && o !== e && (hi++, Vt !== null && (n === null ? n = Vt : n.push(...Vt))), f } catch (v) { zd(v) } finally { Rt = t, Ft = r, Vt = n, ot = o, Ue = i, Pt = s, Xa(a), qt = l, e.f ^= bs } } function Vd(e, t) { let r = t.reactions; if (r !== null) { var n = ju.call(r, e); if (n !== -1) { var o = r.length - 1; o === 0 ? r = t.reactions = null : (r[n] = r[o], r.pop()) } } r === null && (t.f & Xt) !== 0 && (Rt === null || !Rt.includes(t)) && (ae(t, hr), (t.f & (Bt | fi)) === 0 && (t.f ^= fi), $l(t), gi(t, 0)) } function gi(e, t) { var r = e.deps; if (r !== null) for (var n = t; n < r.length; n++)Vd(e, r[n]) } function ua(e) { var t = e.f; if ((t & oa) === 0) { ae(e, Gt); var r = st, n = lr; st = e, lr = !0; try { (t & ra) !== 0 ? Dd(e) : cc(e), lc(e); var o = wc(e); e.teardown = typeof o == "function" ? o : null, e.wv = vc; var i; qa && ld && (e.f & Pe) !== 0 && e.deps } finally { lr = n, st = r } } } function Hd() { try { nd() } catch (e) { if (An !== null) gc(e, An); else throw e } } function yc() { var e = lr; try { var t = 0; for (lr = !0; mn.length > 0;) { t++ > 1e3 && Hd(); var r = mn, n = r.length; mn = []; for (var o = 0; o < n; o++) { var i = jd(r[o]); Ud(i) } yn.clear() } } finally { Sn = !1, lr = e, An = null } } function Ud(e) { var t = e.length; if (t !== 0) for (var r = 0; r < t; r++) { var n = e[r]; (n.f & (oa | Se)) === 0 && ts(n) && (ua(n), n.deps === null && n.first === null && n.nodes_start === null && (n.teardown === null ? uc(n) : n.fn = null)) } } function da(e) { Sn || (Sn = !0, queueMicrotask(yc)); for (var t = An = e; t.parent !== null;) { t = t.parent; var r = t.f; if ((r & (fr | Ce)) !== 0) { if ((r & Gt) === 0) return; t.f ^= Gt } } mn.push(t) } function jd(e) { for (var t = [], r = e; r !== null;) { var n = r.f, o = (n & (Ce | fr)) !== 0, i = o && (n & Gt) !== 0; if (!i && (n & Se) === 0) { (n & jl) !== 0 ? t.push(r) : o ? r.f ^= Gt : ts(r) && ua(r); var s = r.first; if (s !== null) { r = s; continue } } var a = r.parent; for (r = r.next; r === null && a !== null;)r = a.next, a = a.parent } return t } function Kd(e) { for (var t; ;) { if (Bd(), mn.length === 0) return Sn = !1, An = null, t; Sn = !0, yc() } } async function _c() { await Promise.resolve(), Kd() } function g(e) { var t = e.f, r = (t & Xt) !== 0; if (ot !== null && !qt) { if (!(Pt != null && Pt[1].includes(e)) || Pt[0] !== ot) { var n = ot.deps; e.rv < hi && (e.rv = hi, Rt === null && n !== null && n[Ft] === e ? Ft++ : Rt === null ? Rt = [e] : (!Ue || !Rt.includes(e)) && Rt.push(e)) } } else if (r && e.deps === null && e.effects === null) { var o = e, i = o.parent; i !== null && (i.f & Bt) === 0 && (o.f ^= Bt) } return r && (o = e, ts(o) && ec(o)), Jr && yn.has(e) ? yn.get(e) : e.v } function at(e) { var t = qt; try { return qt = !0, e() } finally { qt = t } } const Gd = -7169; function ae(e, t) { e.f = e.f & Gd | t } function qd(e) { if (!(typeof e != "object" || !e || e instanceof EventTarget)) { if (oe in e) _s(e); else if (!Array.isArray(e)) for (let t in e) { const r = e[t]; typeof r == "object" && r && oe in r && _s(r) } } } function _s(e, t = new Set) { if (typeof e == "object" && e !== null && !(e instanceof EventTarget) && !t.has(e)) { t.add(e), e instanceof Date && e.getTime(); for (let n in e) try { _s(e[n], t) } catch { } const r = ea(e); if (r !== Object.prototype && r !== Array.prototype && r !== Map.prototype && r !== Set.prototype && r !== Date.prototype) { const n = Ul(r); for (let o in n) { const i = n[o].get; if (i) try { i.call(e) } catch { } } } } } function Yd() { return Symbol(Jl) } function Xd(e) { return e.endsWith("capture") && e !== "gotpointercapture" && e !== "lostpointercapture" } const Zd = ["beforeinput", "click", "change", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"]; function Jd(e) { return Zd.includes(e) } const Qd = { formnovalidate: "formNoValidate", ismap: "isMap", nomodule: "noModule", playsinline: "playsInline", readonly: "readOnly", defaultvalue: "defaultValue", defaultchecked: "defaultChecked", srcobject: "srcObject", novalidate: "noValidate", allowfullscreen: "allowFullscreen", disablepictureinpicture: "disablePictureInPicture", disableremoteplayback: "disableRemotePlayback" }; function $d(e) { return e = e.toLowerCase(), Qd[e] ?? e } const tf = ["touchstart", "touchmove"]; function ef(e) { return tf.includes(e) } function rf(e, t) { if (t) { const r = document.body; e.autofocus = !0, $i(() => { document.activeElement === r && e.focus() }) } } let tl = !1; function nf() { tl || (tl = !0, document.addEventListener("reset", e => { Promise.resolve().then(() => { var t; if (!e.defaultPrevented) for (const r of e.target.elements) (t = r.__on_r) == null || t.call(r) }) }, { capture: !0 })) } function xc(e) { var t = ot, r = st; se(null), qe(null); try { return e() } finally { se(t), qe(r) } } function of(e, t, r, n = r) { e.addEventListener(t, () => xc(r)); const o = e.__on_r; o ? e.__on_r = () => { o(), n(!0) } : e.__on_r = () => n(!0), nf() } const Sc = new Set, xs = new Set; function fa(e, t, r, n = {}) { function o(i) { if (n.capture || gn.call(t, i), !i.cancelBubble) return xc(() => r == null ? void 0 : r.call(this, i)) } return e.startsWith("pointer") || e.startsWith("touch") || e === "wheel" ? $i(() => { t.addEventListener(e, o, n) }) : t.addEventListener(e, o, n), o } function Tt(e, t, r, n = {}) { var o = fa(t, e, r, n); return () => { e.removeEventListener(t, o, n) } } function sf(e, t, r, n, o) { var i = { capture: n, passive: o }, s = fa(e, t, r, i); (t === document.body || t === window || t === document || t instanceof HTMLMediaElement) && ac(() => { t.removeEventListener(e, s, i) }) } function af(e) { for (var t = 0; t < e.length; t++)Sc.add(e[t]); for (var r of xs) r(e) } function gn(e) { var x; var t = this, r = t.ownerDocument, n = e.type, o = ((x = e.composedPath) == null ? void 0 : x.call(e)) || [], i = o[0] || e.target, s = 0, a = e.__root; if (a) { var l = o.indexOf(a); if (l !== -1 && (t === document || t === window)) { e.__root = t; return } var u = o.indexOf(t); if (u === -1) return; l <= u && (s = l) } if (i = o[s] || e.target, i !== t) { Ku(e, "currentTarget", { configurable: !0, get() { return i || r } }); var f = ot, d = st; se(null), qe(null); try { for (var h, p = []; i !== null;) { var v = i.assignedSlot || i.parentNode || i.host || null; try { var w = i["__" + n]; if (w != null && (!i.disabled || e.target === i)) if (Yi(w)) { var [_, ...S] = w; _.apply(i, [e, ...S]) } else w.call(i, e) } catch (b) { h ? p.push(b) : h = b } if (e.cancelBubble || v === t || v === null) break; i = v } if (h) { for (let b of p) queueMicrotask(() => { throw b }); throw h } } finally { e.__root = t, delete e.currentTarget, se(f), qe(d) } } } function Ac(e) { var t = document.createElement("template"); return t.innerHTML = e.replaceAll("<!>", "<!---->"), t.content } function jr(e, t) { var r = st; r.nodes_start === null && (r.nodes_start = e, r.nodes_end = t) } function rt(e, t) { var r = (t & md) !== 0, n = (t & bd) !== 0, o, i = !e.startsWith("<!>"); return () => { o === void 0 && (o = Ac(i ? e : "<!>" + e), r || (o = Ur(o))); var s = n || nc ? document.importNode(o, !0) : o.cloneNode(!0); if (r) { var a = Ur(s), l = s.lastChild; jr(a, l) } else jr(s, s); return s } } function lf(e, t, r = "svg") { var n = !e.startsWith("<!>"), o = `<${r}>${n ? e : "<!>" + e}</${r}>`, i; return () => { if (!i) { var s = Ac(o), a = Ur(s); i = Ur(a) } var l = i.cloneNode(!0); return jr(l, l), l } } function cf(e, t) { return lf(e, t, "svg") } function pt(e = "") { { var t = qo(e + ""); return jr(t, t), t } } function H() { var e = document.createDocumentFragment(), t = document.createComment(""), r = qo(); return e.append(t, r), jr(t, r), e } function O(e, t) { e !== null && e.before(t) } function Qr() { var e; return (e = window.__svelte ?? (window.__svelte = {})).uid ?? (e.uid = 1), `c${window.__svelte.uid++}` } function At(e, t) { var r = t == null ? "" : typeof t == "object" ? t + "" : t; r !== (e.__t ?? (e.__t = e.nodeValue)) && (e.__t = r, e.nodeValue = r + "") } function Pc(e, t) { return uf(e, t) } const wr = new Map; function uf(e, { target: t, anchor: r, props: n = {}, events: o, context: i, intro: s = !0 }) { Td(); var a = new Set, l = d => { for (var h = 0; h < d.length; h++) { var p = d[h]; if (!a.has(p)) { a.add(p); var v = ef(p); t.addEventListener(p, gn, { passive: v }); var w = wr.get(p); w === void 0 ? (document.addEventListener(p, gn, { passive: v }), wr.set(p, 1)) : wr.set(p, w + 1) } } }; l(ta(Sc)), xs.add(l); var u = void 0, f = Md(() => { var d = r ?? t.appendChild(qo()); return Zt(() => { if (i) { Z({}); var h = lt; h.c = i } o && (n.$$events = o), u = e(d, n) || {}, i && J() }), () => { var v; for (var h of a) { t.removeEventListener(h, gn); var p = wr.get(h); --p === 0 ? (document.removeEventListener(h, gn), wr.delete(h)) : wr.set(h, p) } xs.delete(l), d !== r && ((v = d.parentNode) == null || v.removeChild(d)) } }); return Ss.set(u, f), u } let Ss = new WeakMap; function df(e, t) { const r = Ss.get(e); return r ? (Ss.delete(e), r(t)) : Promise.resolve() } function dt(e, t, [r, n] = [0, 0]) { var o = e, i = null, s = null, a = It, l = r > 0 ? Yr : 0, u = !1; const f = (h, p = !0) => { u = !0, d(p, h) }, d = (h, p) => { a !== (a = h) && (a ? (i ? _n(i) : p && (i = Zt(() => p(o))), s && ur(s, () => { s = null })) : (s ? _n(s) : p && (s = Zt(() => p(o, [r + 1, n]))), i && ur(i, () => { i = null }))) }; Te(() => { u = !1, t(f), u || d(null, null) }, l) } function ff(e, t, r) { var n = e, o = It, i, s = Zr() ? $u : Xl; Te(() => { s(o, o = t()) && (i && ur(i), i = Zt(() => r(n))) }) } function ai(e, t) { return t } function hf(e, t, r, n) { for (var o = [], i = t.length, s = 0; s < i; s++)ca(t[s].e, o, !0); var a = i > 0 && o.length === 0 && r !== null; if (a) { var l = r.parentNode; kd(l), l.append(r), n.clear(), Me(e, t[0].prev, t[i - 1].next) } dc(o, () => { for (var u = 0; u < i; u++) { var f = t[u]; a || (n.delete(f.k), Me(e, f.prev, f.next)), Dt(f.e, !a) } }) } function bn(e, t, r, n, o, i = null) { var s = e, a = { flags: t, items: new Map, first: null }, l = (t & Zl) !== 0; if (l) { var u = e; s = u.appendChild(qo()) } var f = null, d = !1, h = re(() => { var p = r(); return Yi(p) ? p : p == null ? [] : ta(p) }); Te(() => { var p = g(h), v = p.length; d && v === 0 || (d = v === 0, gf(p, a, s, o, t, n, r), i !== null && (v === 0 ? f ? _n(f) : f = Zt(() => i(s)) : f !== null && ur(f, () => { f = null })), g(h)) }) } function gf(e, t, r, n, o, i, s) { var R, U, $, tt; var a = (o & ud) !== 0, l = (o & (sa | aa)) !== 0, u = e.length, f = t.items, d = t.first, h = d, p, v = null, w, _ = [], S = [], x, b, m, A; if (a) for (A = 0; A < u; A += 1)x = e[A], b = i(x, A), m = f.get(b), m !== void 0 && ((R = m.a) == null || R.measure(), (w ?? (w = new Set)).add(m)); for (A = 0; A < u; A += 1) { if (x = e[A], b = i(x, A), m = f.get(b), m === void 0) { var I = h ? h.e.nodes_start : r; v = vf(I, t, v, v === null ? t.first : v.next, x, b, A, n, o, s), f.set(b, v), _ = [], S = [], h = v.next; continue } if (l && pf(m, x, A, o), (m.e.f & Se) !== 0 && (_n(m.e), a && ((U = m.a) == null || U.unfix(), (w ?? (w = new Set)).delete(m))), m !== h) { if (p !== void 0 && p.has(m)) { if (_.length < S.length) { var P = S[0], C; v = P.prev; var W = _[0], q = _[_.length - 1]; for (C = 0; C < _.length; C += 1)el(_[C], P, r); for (C = 0; C < S.length; C += 1)p.delete(S[C]); Me(t, W.prev, q.next), Me(t, v, W), Me(t, q, P), h = P, v = q, A -= 1, _ = [], S = [] } else p.delete(m), el(m, h, r), Me(t, m.prev, m.next), Me(t, m, v === null ? t.first : v.next), Me(t, v, m), v = m; continue } for (_ = [], S = []; h !== null && h.k !== b;)(h.e.f & Se) === 0 && (p ?? (p = new Set)).add(h), S.push(h), h = h.next; if (h === null) continue; m = h } _.push(m), v = m, h = m.next } if (h !== null || p !== void 0) { for (var j = p === void 0 ? [] : ta(p); h !== null;)(h.e.f & Se) === 0 && j.push(h), h = h.next; var K = j.length; if (K > 0) { var z = (o & Zl) !== 0 && u === 0 ? r : null; if (a) { for (A = 0; A < K; A += 1)($ = j[A].a) == null || $.measure(); for (A = 0; A < K; A += 1)(tt = j[A].a) == null || tt.fix() } hf(t, j, z, f) } } a && $i(() => { var D; if (w !== void 0) for (m of w) (D = m.a) == null || D.apply() }), st.first = t.first && t.first.e, st.last = v && v.e } function pf(e, t, r, n) { (n & sa) !== 0 && ws(e.v, t), (n & aa) !== 0 ? ws(e.i, r) : e.i = r } function vf(e, t, r, n, o, i, s, a, l, u) { var f = (l & sa) !== 0, d = (l & dd) === 0, h = f ? d ? Ar(o, !1, !1) : jt(o) : o, p = (l & aa) === 0 ? s : jt(s), v = { i: p, v: h, k: i, a: null, e: null, prev: r, next: n }; try { return v.e = Zt(() => a(e, h, p, u), Cd), v.e.prev = r && r.e, v.e.next = n && n.e, r === null ? t.first = v : (r.next = v, r.e.next = v.e), n !== null && (n.prev = v, n.e.prev = v.e), v } finally { } } function el(e, t, r) { for (var n = e.next ? e.next.e.nodes_start : r, o = t ? t.e.nodes_start : r, i = e.e.nodes_start; i !== n;) { var s = Ji(i); o.before(i), i = s } } function Me(e, t, r) { t === null ? e.first = r : (t.next = r, t.e.next = r && r.e), r !== null && (r.prev = t, r.e.prev = t && t.e) } function Y(e, t, ...r) { var n = e, o = et, i; Te(() => { o !== (o = t()) && (i && (Dt(i), i = null), i = Zt(() => o(n, ...r))) }, Yr) } function Ke(e, t, r) { var n = e, o, i; Te(() => { o !== (o = t()) && (i && (ur(i), i = null), o && (i = Zt(() => r(n, o)))) }, Yr) } function mf(e, t, r, n, o, i) { var s, a, l = null, u = e, f; Te(() => { const d = t() || null; var h = yd; d !== s && (f && (d === null ? ur(f, () => { f = null, a = null }) : d === a ? _n(f) : Dt(f)), d && d !== a && (f = Zt(() => { if (l = document.createElementNS(h, d), jr(l, l), n) { var p = l.appendChild(qo()); n(l, p) } st.nodes_end = l, u.before(l) })), s = d, s && (a = s)) }, Yr) } function bf(e, t) { var r = void 0, n; Te(() => { r !== (r = t()) && (n && (Dt(n), n = null), r && (n = Zt(() => { Yo(() => r(e)) }))) }) } function Ec(e) { var t, r, n = ""; if (typeof e == "string" || typeof e == "number") n += e; else if (typeof e == "object") if (Array.isArray(e)) { var o = e.length; for (t = 0; t < o; t++)e[t] && (r = Ec(e[t])) && (n && (n += " "), n += r) } else for (r in e) e[r] && (n && (n += " "), n += r); return n } function wn() { for (var e, t, r = 0, n = "", o = arguments.length; r < o; r++)(e = arguments[r]) && (t = Ec(e)) && (n && (n += " "), n += t); return n } function wf(e) { return typeof e == "object" ? wn(e) : e ?? "" } const rl = [...` 	
\r\f \v\uFEFF`]; function yf(e, t, r) { var n = e == null ? "" : "" + e; if (r) { for (var o in r) if (r[o]) n = n ? n + " " + o : o; else if (n.length) for (var i = o.length, s = 0; (s = n.indexOf(o, s)) >= 0;) { var a = s + i; (s === 0 || rl.includes(n[s - 1])) && (a === n.length || rl.includes(n[a])) ? n = (s === 0 ? "" : n.substring(0, s)) + n.substring(a + 1) : s = a } } return n === "" ? null : n } function nl(e, t = !1) { var r = t ? " !important;" : ";", n = ""; for (var o in e) { var i = e[o]; i != null && i !== "" && (n += " " + o + ": " + i + r) } return n } function cs(e) { return e[0] !== "-" || e[1] !== "-" ? e.toLowerCase() : e } function _f(e, t) { if (t) { var r = "", n, o; if (Array.isArray(t) ? (n = t[0], o = t[1]) : n = t, e) { e = String(e).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim(); var i = !1, s = 0, a = !1, l = []; n && l.push(...Object.keys(n).map(cs)), o && l.push(...Object.keys(o).map(cs)); var u = 0, f = -1; const w = e.length; for (var d = 0; d < w; d++) { var h = e[d]; if (a ? h === "/" && e[d - 1] === "*" && (a = !1) : i ? i === h && (i = !1) : h === "/" && e[d + 1] === "*" ? a = !0 : h === '"' || h === "'" ? i = h : h === "(" ? s++ : h === ")" && s--, !a && i === !1 && s === 0) { if (h === ":" && f === -1) f = d; else if (h === ";" || d === w - 1) { if (f !== -1) { var p = cs(e.substring(u, f).trim()); if (!l.includes(p)) { h !== ";" && d++; var v = e.substring(u, d).trim(); r += " " + v + ";" } } u = d + 1, f = -1 } } } } return n && (r += nl(n)), o && (r += nl(o, !0)), r = r.trim(), r === "" ? null : r } return e == null ? null : String(e) } function xf(e, t, r, n, o, i) { var s = e.__className; if (s !== r || s === void 0) { var a = yf(r, n, i); a == null ? e.removeAttribute("class") : t ? e.className = a : e.setAttribute("class", a), e.__className = r } else if (i && o !== i) for (var l in i) { var u = !!i[l]; (o == null || u !== !!o[l]) && e.classList.toggle(l, u) } return i } function us(e, t = {}, r, n) { for (var o in r) { var i = r[o]; t[o] !== i && (r[o] == null ? e.style.removeProperty(o) : e.style.setProperty(o, i, n)) } } function Sf(e, t, r, n) { var o = e.__style; if (o !== t) { var i = _f(t, n); i == null ? e.removeAttribute("style") : e.style.cssText = i, e.__style = t } else n && (Array.isArray(n) ? (us(e, r == null ? void 0 : r[0], n[0]), us(e, r == null ? void 0 : r[1], n[1], "important")) : us(e, r, n)); return n } function As(e, t, r) { if (e.multiple) { if (t == null) return; if (!Yi(t)) return Od(); for (var n of e.options) n.selected = t.includes(ol(n)); return } for (n of e.options) { var o = ol(n); if (Pd(o, t)) { n.selected = !0; return } } (!r || t !== void 0) && (e.selectedIndex = -1) } function Af(e, t) { let r = !0; Yo(() => { t && As(e, at(t), r), r = !1; var n = new MutationObserver(() => { var o = e.__value; As(e, o) }); return n.observe(e, { childList: !0, subtree: !0, attributes: !0, attributeFilter: ["value"] }), () => { n.disconnect() } }) } function ol(e) { return "__value" in e ? e.__value : e.value } const dn = Symbol("class"), fn = Symbol("style"), Oc = Symbol("is custom element"), Cc = Symbol("is html"); function Pf(e, t) { t ? e.hasAttribute("selected") || e.setAttribute("selected", "") : e.removeAttribute("selected") } function il(e, t, r, n) { var o = Tc(e); o[t] !== (o[t] = r) && (t === "loading" && (e[Qu] = r), r == null ? e.removeAttribute(t) : typeof r != "string" && kc(e).includes(t) ? e[t] = r : e.setAttribute(t, r)) } function Ef(e, t, r, n, o = !1) { var i = Tc(e), s = i[Oc], a = !i[Cc], l = t || {}, u = e.tagName === "OPTION"; for (var f in t) f in r || (r[f] = null); r.class ? r.class = wf(r.class) : r[dn] && (r.class = null), r[fn] && (r.style ?? (r.style = null)); var d = kc(e); for (const b in r) { let m = r[b]; if (u && b === "value" && m == null) { e.value = e.__value = "", l[b] = m; continue } if (b === "class") { var h = e.namespaceURI === "http://www.w3.org/1999/xhtml"; xf(e, h, m, n, t == null ? void 0 : t[dn], r[dn]), l[b] = m, l[dn] = r[dn]; continue } if (b === "style") { Sf(e, m, t == null ? void 0 : t[fn], r[fn]), l[b] = m, l[fn] = r[fn]; continue } var p = l[b]; if (!(m === p && !(m === void 0 && e.hasAttribute(b)))) { l[b] = m; var v = b[0] + b[1]; if (v !== "$$") if (v === "on") { const A = {}, I = "$$" + b; let P = b.slice(2); var w = Jd(P); if (Xd(P) && (P = P.slice(0, -7), A.capture = !0), !w && p) { if (m != null) continue; e.removeEventListener(P, l[I], A), l[I] = null } if (m != null) if (w) e[`__${P}`] = m, af([P]); else { let C = function (W) { l[b].call(this, W) }; var x = C; l[I] = fa(P, e, C, A) } else w && (e[`__${P}`] = void 0) } else if (b === "style") il(e, b, m); else if (b === "autofocus") rf(e, !!m); else if (!s && (b === "__value" || b === "value" && m != null)) e.value = e.__value = m; else if (b === "selected" && u) Pf(e, m); else { var _ = b; a || (_ = $d(_)); var S = _ === "defaultValue" || _ === "defaultChecked"; if (m == null && !s && !S) if (i[b] = null, _ === "value" || _ === "checked") { let A = e; const I = t === void 0; if (_ === "value") { let P = A.defaultValue; A.removeAttribute(_), A.defaultValue = P, A.value = A.__value = I ? P : null } else { let P = A.defaultChecked; A.removeAttribute(_), A.defaultChecked = P, A.checked = I ? P : !1 } } else e.removeAttribute(b); else S || d.includes(_) && (s || typeof m != "string") ? e[_] = m : typeof m != "function" && il(e, _, m) } } } return l } function mt(e, t, r = [], n, o = !1, i = cr) { const s = r.map(i); var a = void 0, l = {}, u = e.nodeName === "SELECT", f = !1; Te(() => { var d = t(...s.map(g)), h = Ef(e, a, d, n, o); f && u && "value" in d && As(e, d.value, !1); for (let v of Object.getOwnPropertySymbols(l)) d[v] || Dt(l[v]); for (let v of Object.getOwnPropertySymbols(d)) { var p = d[v]; v.description === Jl && (!a || p !== a[v]) && (l[v] && Dt(l[v]), l[v] = Zt(() => bf(e, () => p))), h[v] = p } a = h }), u && Af(e, () => a.value), f = !0 } function Tc(e) { return e.__attributes ?? (e.__attributes = { [Oc]: e.nodeName.includes("-"), [Cc]: e.namespaceURI === wd }) } var sl = new Map; function kc(e) { var t = sl.get(e.nodeName); if (t) return t; sl.set(e.nodeName, t = []); for (var r, n = e, o = Element.prototype; o !== n;) { r = Ul(n); for (var i in r) r[i].set && t.push(i); n = ea(n) } return t } function Of(e, t, r = t) { var n = Zr(); of(e, "input", o => { var i = o ? e.defaultValue : e.value; if (i = ds(e) ? fs(i) : i, r(i), n && i !== (i = t())) { var s = e.selectionStart, a = e.selectionEnd; e.value = i ?? "", a !== null && (e.selectionStart = s, e.selectionEnd = Math.min(a, e.value.length)) } }), at(t) == null && e.value && r(ds(e) ? fs(e.value) : e.value), Qi(() => { var o = t(); ds(e) && o === fs(e.value) || e.type === "date" && !o && !e.value || o !== e.value && (e.value = o ?? "") }) } function ds(e) { var t = e.type; return t === "number" || t === "range" } function fs(e) { return e === "" ? null : +e } function al(e, t) { return e === t || (e == null ? void 0 : e[oe]) === t } function pr(e = {}, t, r, n) { return Yo(() => { var o, i; return Qi(() => { o = i, i = [], at(() => { e !== r(...i) && (t(e, ...i), o && al(r(...o), e) && t(null, ...o)) }) }), () => { $i(() => { i && al(r(...i), e) && t(null, ...i) }) } }), e } function Cf(e = !1) { const t = lt, r = t.l.u; if (!r) return; let n = () => qd(t.s); if (e) { let o = 0, i = {}; const s = cr(() => { let a = !1; const l = t.s; for (const u in l) l[u] !== i[u] && (i[u] = l[u], a = !0); return a && o++, o }); n = () => g(s) } r.b.length && la(() => { ll(t, n), di(r.b) }), yt(() => { const o = at(() => r.m.map(Yu)); return () => { for (const i of o) typeof i == "function" && i() } }), r.a.length && yt(() => { ll(t, n), di(r.a) }) } function ll(e, t) { if (e.l.s) for (const r of e.l.s) g(r); t() } let ri = !1; function Tf(e) { var t = ri; try { return ri = !1, [e(), ri] } finally { ri = t } } const kf = { get(e, t) { if (!e.exclude.includes(t)) return e.props[t] }, set(e, t) { return !1 }, getOwnPropertyDescriptor(e, t) { if (!e.exclude.includes(t) && t in e.props) return { enumerable: !0, configurable: !0, value: e.props[t] } }, has(e, t) { return e.exclude.includes(t) ? !1 : t in e.props }, ownKeys(e) { return Reflect.ownKeys(e.props).filter(t => !e.exclude.includes(t)) } }; function ct(e, t, r) { return new Proxy({ props: e, exclude: t }, kf) } const Nf = { get(e, t) { let r = e.props.length; for (; r--;) { let n = e.props[r]; if (un(n) && (n = n()), typeof n == "object" && n !== null && t in n) return n[t] } }, set(e, t, r) { let n = e.props.length; for (; n--;) { let o = e.props[n]; un(o) && (o = o()); const i = je(o, t); if (i && i.set) return i.set(r), !0 } return !1 }, getOwnPropertyDescriptor(e, t) { let r = e.props.length; for (; r--;) { let n = e.props[r]; if (un(n) && (n = n()), typeof n == "object" && n !== null && t in n) { const o = je(n, t); return o && !o.configurable && (o.configurable = !0), o } } }, has(e, t) { if (t === oe || t === ql) return !1; for (let r of e.props) if (un(r) && (r = r()), r != null && t in r) return !0; return !1 }, ownKeys(e) { const t = []; for (let r of e.props) if (un(r) && (r = r()), !!r) { for (const n in r) t.includes(n) || t.push(n); for (const n of Object.getOwnPropertySymbols(r)) t.includes(n) || t.push(n) } return t } }; function Mt(...e) { return new Proxy({ props: e }, Nf) } function cl(e) { var t; return ((t = e.ctx) == null ? void 0 : t.d) ?? !1 } function E(e, t, r, n) { var I; var o = (r & fd) !== 0, i = !Xr || (r & hd) !== 0, s = (r & pd) !== 0, a = (r & vd) !== 0, l = !1, u; s ? [u, l] = Tf(() => e[t]) : u = e[t]; var f = oe in e || ql in e, d = s && (((I = je(e, t)) == null ? void 0 : I.set) ?? (f && t in e && (P => e[t] = P))) || void 0, h = n, p = !0, v = !1, w = () => (v = !0, p && (p = !1, a ? h = at(n) : h = n), h); u === void 0 && n !== void 0 && (d && i && od(), u = w(), d && d(u)); var _; if (i) _ = () => { var P = e[t]; return P === void 0 ? w() : (p = !0, v = !1, P) }; else { var S = (o ? cr : re)(() => e[t]); S.f |= Zu, _ = () => { var P = g(S); return P !== void 0 && (h = void 0), P === void 0 ? h : P } } if ((r & gd) === 0 && i) return _; if (d) { var x = e.$$legacy; return function (P, C) { return arguments.length > 0 ? ((!i || !C || x || l) && d(C ? _() : P), P) : _() } } var b = !1, m = Ar(u), A = cr(() => { var P = _(), C = g(m); return b ? (b = !1, C) : m.v = P }); return s && g(A), o || (A.equals = ia), function (P, C) { if (arguments.length > 0) { const W = C ? g(A) : i && s ? Kt(P) : P; if (!A.equals(W)) { if (b = !0, N(m, W), v && h !== void 0 && (h = W), cl(A)) return P; at(() => g(A)) } return P } return cl(A) ? A.v : g(A) } } function Nc(e) { lt === null && Ql(), Xr && lt.l !== null ? If(lt).m.push(e) : yt(() => { const t = at(e); if (typeof t == "function") return t }) } function If(e) { var t = e.l; return t.u ?? (t.u = { a: [], b: [], m: [] }) } const Rf = "5"; var Hl; typeof window < "u" && ((Hl = window.__svelte ?? (window.__svelte = {})).v ?? (Hl.v = new Set)).add(Rf); cd(); function Mf(e) { return typeof e == "function" } function Xo(e) { return e !== null && typeof e == "object" } const Df = ["string", "number", "bigint", "boolean"]; function Ps(e) { return e == null || Df.includes(typeof e) ? !0 : Array.isArray(e) ? e.every(t => Ps(t)) : typeof e == "object" ? Object.getPrototypeOf(e) === Object.prototype : !1 } const Pn = Symbol("box"), ha = Symbol("is-writable"); function Ff(e) { return Xo(e) && Pn in e } function Lf(e) { return T.isBox(e) && ha in e } function T(e) { let t = X(Kt(e)); return { [Pn]: !0, [ha]: !0, get current() { return g(t) }, set current(r) { N(t, r, !0) } } } function Bf(e, t) { const r = M(e); return t ? { [Pn]: !0, [ha]: !0, get current() { return g(r) }, set current(n) { t(n) } } : { [Pn]: !0, get current() { return e() } } } function zf(e) { return T.isBox(e) ? e : Mf(e) ? T.with(e) : T(e) } function Wf(e) { return Object.entries(e).reduce((t, [r, n]) => T.isBox(n) ? (T.isWritableBox(n) ? Object.defineProperty(t, r, { get() { return n.current }, set(o) { n.current = o } }) : Object.defineProperty(t, r, { get() { return n.current } }), t) : Object.assign(t, { [r]: n }), {}) } function Vf(e) { return T.isWritableBox(e) ? { [Pn]: !0, get current() { return e.current } } : e } T.from = zf; T.with = Bf; T.flatten = Wf; T.readonly = Vf; T.isBox = Ff; T.isWritableBox = Lf; function Ic(...e) { return function (t) { var r; for (const n of e) if (n) { if (t.defaultPrevented) return; typeof n == "function" ? n.call(this, t) : (r = n.current) == null || r.call(this, t) } } } function Hf(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var yr = {}, hs, ul; function Uf() {
  if (ul) return hs; ul = 1; var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, r = /^\s*/, n = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, o = /^:\s*/, i = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, s = /^[;\s]*/, a = /^\s+|\s+$/g, l = `
`, u = "/", f = "*", d = "", h = "comment", p = "declaration"; hs = function (w, _) { if (typeof w != "string") throw new TypeError("First argument must be a string"); if (!w) return []; _ = _ || {}; var S = 1, x = 1; function b(z) { var R = z.match(t); R && (S += R.length); var U = z.lastIndexOf(l); x = ~U ? z.length - U : x + z.length } function m() { var z = { line: S, column: x }; return function (R) { return R.position = new A(z), C(), R } } function A(z) { this.start = z, this.end = { line: S, column: x }, this.source = _.source } A.prototype.content = w; function I(z) { var R = new Error(_.source + ":" + S + ":" + x + ": " + z); if (R.reason = z, R.filename = _.source, R.line = S, R.column = x, R.source = w, !_.silent) throw R } function P(z) { var R = z.exec(w); if (R) { var U = R[0]; return b(U), w = w.slice(U.length), R } } function C() { P(r) } function W(z) { var R; for (z = z || []; R = q();)R !== !1 && z.push(R); return z } function q() { var z = m(); if (!(u != w.charAt(0) || f != w.charAt(1))) { for (var R = 2; d != w.charAt(R) && (f != w.charAt(R) || u != w.charAt(R + 1));)++R; if (R += 2, d === w.charAt(R - 1)) return I("End of comment missing"); var U = w.slice(2, R - 2); return x += 2, b(U), w = w.slice(R), x += 2, z({ type: h, comment: U }) } } function j() { var z = m(), R = P(n); if (R) { if (q(), !P(o)) return I("property missing ':'"); var U = P(i), $ = z({ type: p, property: v(R[0].replace(e, d)), value: U ? v(U[0].replace(e, d)) : d }); return P(s), $ } } function K() { var z = []; W(z); for (var R; R = j();)R !== !1 && (z.push(R), W(z)); return z } return C(), K() }; function v(w) { return w ? w.replace(a, d) : d } return hs
} var dl; function jf() { if (dl) return yr; dl = 1; var e = yr && yr.__importDefault || function (n) { return n && n.__esModule ? n : { default: n } }; Object.defineProperty(yr, "__esModule", { value: !0 }), yr.default = r; var t = e(Uf()); function r(n, o) { var i = null; if (!n || typeof n != "string") return i; var s = (0, t.default)(n), a = typeof o == "function"; return s.forEach(function (l) { if (l.type === "declaration") { var u = l.property, f = l.value; a ? o(u, f, l) : f && (i = i || {}, i[u] = f) } }), i } return yr } var Kf = jf(); const fl = Hf(Kf), Gf = fl.default || fl, qf = /\d/, Yf = ["-", "_", "/", "."]; function Xf(e = "") { if (!qf.test(e)) return e !== e.toLowerCase() } function Zf(e) { const t = []; let r = "", n, o; for (const i of e) { const s = Yf.includes(i); if (s === !0) { t.push(r), r = "", n = void 0; continue } const a = Xf(i); if (o === !1) { if (n === !1 && a === !0) { t.push(r), r = i, n = a; continue } if (n === !0 && a === !1 && r.length > 1) { const l = r.at(-1); t.push(r.slice(0, Math.max(0, r.length - 1))), r = l + i, n = a; continue } } r += i, n = a, o = s } return t.push(r), t } function Rc(e) { return e ? Zf(e).map(t => Qf(t)).join("") : "" } function Jf(e) { return $f(Rc(e || "")) } function Qf(e) { return e ? e[0].toUpperCase() + e.slice(1) : "" } function $f(e) { return e ? e[0].toLowerCase() + e.slice(1) : "" } function pn(e) { if (!e) return {}; const t = {}; function r(n, o) { if (n.startsWith("-moz-") || n.startsWith("-webkit-") || n.startsWith("-ms-") || n.startsWith("-o-")) { t[Rc(n)] = o; return } if (n.startsWith("--")) { t[n] = o; return } t[Jf(n)] = o } return Gf(e, r), t } function Pr(...e) { return (...t) => { for (const r of e) typeof r == "function" && r(...t) } } function th(e, t) { const r = RegExp(e, "g"); return n => { if (typeof n != "string") throw new TypeError(`expected an argument of type string, but got ${typeof n}`); return n.match(r) ? n.replace(r, t) : n } } const eh = th(/[A-Z]/, e => `-${e.toLowerCase()}`); function rh(e) {
  if (!e || typeof e != "object" || Array.isArray(e)) throw new TypeError(`expected an argument of type object, but got ${typeof e}`); return Object.keys(e).map(t => `${eh(t)}: ${e[t]};`).join(`
`)
} function ga(e = {}) {
  return rh(e).replace(`
`, " ")
} const nh = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", transform: "translateX(-100%)" }, oh = ga(nh), ih = ["onabort", "onanimationcancel", "onanimationend", "onanimationiteration", "onanimationstart", "onauxclick", "onbeforeinput", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncompositionend", "oncompositionstart", "oncompositionupdate", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onfocusin", "onfocusout", "onformdata", "ongotpointercapture", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"], sh = new Set(ih); function ah(e) { return sh.has(e) } function Yt(...e) {
  const t = { ...e[0] }; for (let r = 1; r < e.length; r++) { const n = e[r]; if (n) { for (const o of Object.keys(n)) { const i = t[o], s = n[o], a = typeof i == "function", l = typeof s == "function"; if (a && ah(o)) { const u = i, f = s; t[o] = Ic(u, f) } else if (a && l) t[o] = Pr(i, s); else if (o === "class") { const u = Ps(i), f = Ps(s); u && f ? t[o] = wn(i, s) : u ? t[o] = wn(i) : f && (t[o] = wn(s)) } else if (o === "style") { const u = typeof i == "object", f = typeof s == "object", d = typeof i == "string", h = typeof s == "string"; if (u && f) t[o] = { ...i, ...s }; else if (u && h) { const p = pn(s); t[o] = { ...i, ...p } } else if (d && f) { const p = pn(i); t[o] = { ...p, ...s } } else if (d && h) { const p = pn(i), v = pn(s); t[o] = { ...p, ...v } } else u ? t[o] = i : f ? t[o] = s : d ? t[o] = i : h && (t[o] = s) } else t[o] = s !== void 0 ? s : i } for (const o of Object.getOwnPropertySymbols(n)) { const i = t[o], s = n[o]; t[o] = s !== void 0 ? s : i } } } return typeof t.style == "object" && (t.style = ga(t.style).replaceAll(`
`, " ")), t.hidden !== !0 && (t.hidden = void 0, delete t.hidden), t.disabled !== !0 && (t.disabled = void 0, delete t.disabled), t
} const Mc = typeof window < "u" ? window : void 0; function lh(e) { let t = e.activeElement; for (; t != null && t.shadowRoot;) { const r = t.shadowRoot.activeElement; if (r === t) break; t = r } return t } function xr(e) { N(e, e.v + 1) } var te, ee, pe, Or, li; const Ia = class Ia extends Map { constructor(r) { super(); y(this, Or); y(this, te, new Map); y(this, ee, jt(0)); y(this, pe, jt(0)); if (r) { for (var [n, o] of r) super.set(n, o); c(this, pe).v = super.size } } has(r) { var n = c(this, te), o = n.get(r); if (o === void 0) { var i = super.get(r); if (i !== void 0) o = jt(0), n.set(r, o); else return g(c(this, ee)), !1 } return g(o), !0 } forEach(r, n) { it(this, Or, li).call(this), super.forEach(r, n) } get(r) { var n = c(this, te), o = n.get(r); if (o === void 0) { var i = super.get(r); if (i !== void 0) o = jt(0), n.set(r, o); else { g(c(this, ee)); return } } return g(o), super.get(r) } set(r, n) { var d; var o = c(this, te), i = o.get(r), s = super.get(r), a = super.set(r, n), l = c(this, ee); if (i === void 0) i = jt(0), o.set(r, i), N(c(this, pe), super.size), xr(l); else if (s !== n) { xr(i); var u = l.reactions === null ? null : new Set(l.reactions), f = u === null || !((d = i.reactions) != null && d.every(h => u.has(h))); f && xr(l) } return a } delete(r) { var n = c(this, te), o = n.get(r), i = super.delete(r); return o !== void 0 && (n.delete(r), N(c(this, pe), super.size), N(o, -1), xr(c(this, ee))), i } clear() { if (super.size !== 0) { super.clear(); var r = c(this, te); N(c(this, pe), 0); for (var n of r.values()) N(n, -1); xr(c(this, ee)), r.clear() } } keys() { return g(c(this, ee)), super.keys() } values() { return it(this, Or, li).call(this), super.values() } entries() { return it(this, Or, li).call(this), super.entries() } [Symbol.iterator]() { return this.entries() } get size() { return g(c(this, pe)), super.size } }; te = new WeakMap, ee = new WeakMap, pe = new WeakMap, Or = new WeakSet, li = function () { g(c(this, ee)); var r = c(this, te); if (c(this, pe).v !== r.size) { for (var n of Ga(Ia.prototype, this, "keys").call(this)) if (!r.has(n)) { var o = jt(0); r.set(n, o) } } for ([, o] of c(this, te)) g(o) }; let Es = Ia; function Dc(e) { let t = 0, r = jt(0), n; return () => { Id() && (g(r), Qi(() => (t === 0 && (n = at(() => e(() => xr(r)))), t += 1, () => { _c().then(() => { t -= 1, t === 0 && (n == null || n(), n = void 0) }) }))) } } var Cr, Cn; class ch { constructor(t = {}) { y(this, Cr); y(this, Cn); const { window: r = Mc, document: n = r == null ? void 0 : r.document } = t; r !== void 0 && (V(this, Cr, n), V(this, Cn, Dc(o => { const i = Tt(r, "focusin", o), s = Tt(r, "focusout", o); return () => { i(), s() } }))) } get current() { var t; return (t = c(this, Cn)) == null || t.call(this), c(this, Cr) ? lh(c(this, Cr)) : null } } Cr = new WeakMap, Cn = new WeakMap; new ch; function uh(e) { return typeof e == "function" } var Tn, ve; class $r { constructor(t) { y(this, Tn); y(this, ve); V(this, Tn, t), V(this, ve, Symbol(t)) } get key() { return c(this, ve) } exists() { return xd(c(this, ve)) } get() { const t = Za(c(this, ve)); if (t === void 0) throw new Error(`Context "${c(this, Tn)}" not found`); return t } getOr(t) { const r = Za(c(this, ve)); return r === void 0 ? t : r } set(t) { return _d(c(this, ve), t) } } Tn = new WeakMap, ve = new WeakMap; function dh(e, t) { switch (e) { case "post": yt(t); break; case "pre": la(t); break } } function Fc(e, t, r, n = {}) { const { lazy: o = !1 } = n; let i = !o, s = Array.isArray(e) ? [] : void 0; dh(t, () => { const a = Array.isArray(e) ? e.map(u => u()) : e(); if (!i) { i = !0, s = a; return } const l = at(() => r(a, s)); return s = a, l }) } function ft(e, t, r) { Fc(e, "post", t, r) } function fh(e, t, r) { Fc(e, "pre", t, r) } ft.pre = fh; function hl(e) { return uh(e) ? e() : e } var De, Tr, kr, Nr, Fe, Ai, Pi, Ir; class hh { constructor(t, r = { box: "border-box" }) { y(this, De, { width: 0, height: 0 }); y(this, Tr, !1); y(this, kr); y(this, Nr); y(this, Fe); y(this, Ai, M(() => { var t; return (t = g(c(this, Ir))) == null || t(), this.getSize().width })); y(this, Pi, M(() => { var t; return (t = g(c(this, Ir))) == null || t(), this.getSize().height })); y(this, Ir, M(() => { const t = hl(c(this, Nr)); if (t) return Dc(r => { if (!c(this, Fe)) return; const n = new (c(this, Fe)).ResizeObserver(o => { V(this, Tr, !0); for (const i of o) { const s = c(this, kr).box === "content-box" ? i.contentBoxSize : i.borderBoxSize, a = Array.isArray(s) ? s : [s]; c(this, De).width = a.reduce((l, u) => Math.max(l, u.inlineSize), 0), c(this, De).height = a.reduce((l, u) => Math.max(l, u.blockSize), 0) } r() }); return n.observe(t), () => { V(this, Tr, !1), n.disconnect() } }) })); V(this, Fe, r.window ?? Mc), V(this, kr, r), V(this, Nr, t), V(this, De, { width: 0, height: 0 }) } calculateSize() { const t = hl(c(this, Nr)); if (!t || !c(this, Fe)) return; const r = t.offsetWidth, n = t.offsetHeight; if (c(this, kr).box === "border-box") return { width: r, height: n }; const o = c(this, Fe).getComputedStyle(t), i = parseFloat(o.paddingLeft) + parseFloat(o.paddingRight), s = parseFloat(o.paddingTop) + parseFloat(o.paddingBottom), a = parseFloat(o.borderLeftWidth) + parseFloat(o.borderRightWidth), l = parseFloat(o.borderTopWidth) + parseFloat(o.borderBottomWidth), u = r - i - a, f = n - s - l; return { width: u, height: f } } getSize() { return c(this, Tr) ? c(this, De) : this.calculateSize() ?? c(this, De) } get current() { var t; return (t = g(c(this, Ir))) == null || t(), this.getSize() } get width() { return g(c(this, Ai)) } get height() { return g(c(this, Pi)) } } De = new WeakMap, Tr = new WeakMap, kr = new WeakMap, Nr = new WeakMap, Fe = new WeakMap, Ai = new WeakMap, Pi = new WeakMap, Ir = new WeakMap; var Rr; class Lc { constructor(t, r) { y(this, Rr, X(void 0)); r !== void 0 && N(c(this, Rr), r, !0), ft(() => t(), (n, o) => { N(c(this, Rr), o, !0) }) } get current() { return g(c(this, Rr)) } } Rr = new WeakMap; function tn(e) { yt(() => () => { e() }) } function pa(e, t) { return setTimeout(t, e) } function Zo(e) { _c().then(e) } function gh(e) { yt(() => at(() => e())) } const ph = 1, vh = 9, mh = 11; function Os(e) { return Xo(e) && e.nodeType === ph && typeof e.nodeName == "string" } function Bc(e) { return Xo(e) && e.nodeType === vh } function bh(e) { var t; return Xo(e) && ((t = e.constructor) == null ? void 0 : t.name) === "VisualViewport" } function wh(e) { return Xo(e) && e.nodeType !== void 0 } function zc(e) { return wh(e) && e.nodeType === mh && "host" in e } function yh(e, t) { var n; if (!e || !t || !Os(e) || !Os(t)) return !1; const r = (n = t.getRootNode) == null ? void 0 : n.call(t); if (e === t || e.contains(t)) return !0; if (r && zc(r)) { let o = t; for (; o;) { if (e === o) return !0; o = o.parentNode || o.host } } return !1 } function _h(e) { return Bc(e) ? e : bh(e) ? e.document : (e == null ? void 0 : e.ownerDocument) ?? document } function Wc(e) { var t; return zc(e) ? Wc(e.host) : Bc(e) ? e.defaultView ?? window : Os(e) ? ((t = e.ownerDocument) == null ? void 0 : t.defaultView) ?? window : window } function xh(e) { let t = e.activeElement; for (; t != null && t.shadowRoot;) { const r = t.shadowRoot.activeElement; if (r === t) break; t = r } return t } var kn; class Jo { constructor(t) { k(this, "element"); y(this, kn, M(() => this.element.current ? this.element.current.getRootNode() ?? document : document)); k(this, "getDocument", () => _h(this.root)); k(this, "getWindow", () => this.getDocument().defaultView ?? window); k(this, "getActiveElement", () => xh(this.root)); k(this, "isActiveElement", t => t === this.getActiveElement()); k(this, "querySelector", t => this.root ? this.root.querySelector(t) : null); k(this, "querySelectorAll", t => this.root ? this.root.querySelectorAll(t) : []); k(this, "setTimeout", (t, r) => this.getWindow().setTimeout(t, r)); k(this, "clearTimeout", t => this.getWindow().clearTimeout(t)); typeof t == "function" ? this.element = T.with(t) : this.element = t } get root() { return g(c(this, kn)) } set root(t) { N(c(this, kn), t) } getElementById(t) { return this.root.getElementById(t) } } kn = new WeakMap; function Ge(e, t) { return { [Yd()]: r => T.isBox(e) ? (e.current = r, at(() => t == null ? void 0 : t(r)), () => { "isConnected" in r && r.isConnected || (e.current = null, t == null || t(null)) }) : (e(r), at(() => t == null ? void 0 : t(r)), () => { "isConnected" in r && r.isConnected || (e(null), t == null || t(null)) }) } } function Vc(e) { return e ? "open" : "closed" } function Sh(e) { return e ? "true" : "false" } function Hc(e) { return e ? "" : void 0 } function Ah(e) { return e ? "true" : void 0 } function Ph(e) { return e ? !0 : void 0 } function Eh(e) { return e ? !0 : void 0 } var Mr, Nn; class Oh { constructor(t) { y(this, Mr); y(this, Nn); k(this, "attrs"); V(this, Mr, t.getVariant ? t.getVariant() : null), V(this, Nn, c(this, Mr) ? `data-${c(this, Mr)}-` : `data-${t.component}-`), this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(t.parts.map(r => [r, this.getAttr(r)])) } getAttr(t, r) { return r ? `data-${r}-${t}` : `${c(this, Nn)}${t}` } selector(t, r) { return `[${this.getAttr(t, r)}]` } } Mr = new WeakMap, Nn = new WeakMap; function Ch(e) { const t = new Oh(e); return { ...t.attrs, selector: t.selector, getAttr: t.getAttr } } const vn = "ArrowDown", Sr = "ArrowUp", Uc = "End", gl = "Enter", Th = "Escape", jc = "Home", Kc = "PageDown", Gc = "PageUp", gs = " ", pl = "Tab"; function gt() { } function en(e, t) { return `bits-${e}` } var In, Ei, qc; class kh { constructor(t, r) { y(this, Ei); k(this, "state"); y(this, In); this.state = T(t), V(this, In, r), this.dispatch = this.dispatch.bind(this) } dispatch(t) { this.state.current = it(this, Ei, qc).call(this, t) } } In = new WeakMap, Ei = new WeakSet, qc = function (t) { return c(this, In)[this.state.current][t] ?? this.state.current }; const Nh = { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }; var Rn, Mn, Dn; class Ih { constructor(t) { k(this, "opts"); y(this, Rn, X("none")); y(this, Mn, X(Kt({}))); k(this, "initialStatus"); k(this, "previousPresent"); k(this, "machine"); k(this, "present"); y(this, Dn, M(() => ["mounted", "unmountSuspended"].includes(this.machine.state.current))); this.opts = t, this.present = this.opts.open, this.initialStatus = t.open.current ? "mounted" : "unmounted", this.previousPresent = new Lc(() => this.present.current), this.machine = new kh(this.initialStatus, Nh), this.handleAnimationEnd = this.handleAnimationEnd.bind(this), this.handleAnimationStart = this.handleAnimationStart.bind(this), Rh(this), Mh(this), Dh(this) } get prevAnimationNameState() { return g(c(this, Rn)) } set prevAnimationNameState(t) { N(c(this, Rn), t, !0) } get styles() { return g(c(this, Mn)) } set styles(t) { N(c(this, Mn), t, !0) } handleAnimationEnd(t) { if (!this.opts.ref.current) return; const r = pi(this.opts.ref.current), n = r.includes(t.animationName) || r === "none"; t.target === this.opts.ref.current && n && this.machine.dispatch("ANIMATION_END") } handleAnimationStart(t) { this.opts.ref.current && t.target === this.opts.ref.current && (this.prevAnimationNameState = pi(this.opts.ref.current)) } get isPresent() { return g(c(this, Dn)) } set isPresent(t) { N(c(this, Dn), t) } } Rn = new WeakMap, Mn = new WeakMap, Dn = new WeakMap; function Rh(e) { ft(() => e.present.current, () => { if (!e.opts.ref.current || !(e.present.current !== e.previousPresent.current)) return; const r = e.prevAnimationNameState, n = pi(e.opts.ref.current); if (e.present.current) e.machine.dispatch("MOUNT"); else if (n === "none" || e.styles.display === "none") e.machine.dispatch("UNMOUNT"); else { const o = r !== n; e.previousPresent.current && o ? e.machine.dispatch("ANIMATION_OUT") : e.machine.dispatch("UNMOUNT") } }) } function Mh(e) { ft(() => e.machine.state.current, () => { if (!e.opts.ref.current) return; const t = pi(e.opts.ref.current); e.prevAnimationNameState = e.machine.state.current === "mounted" ? t : "none" }) } function Dh(e) { ft(() => e.opts.ref.current, () => { if (e.opts.ref.current) return e.styles = getComputedStyle(e.opts.ref.current), Pr(Tt(e.opts.ref.current, "animationstart", e.handleAnimationStart), Tt(e.opts.ref.current, "animationcancel", e.handleAnimationEnd), Tt(e.opts.ref.current, "animationend", e.handleAnimationEnd)) }) } function pi(e) { return e && getComputedStyle(e).animationName || "none" } function Fh(e, t) { Z(t, !0); const r = new Ih({ open: T.with(() => t.open), ref: t.ref }); var n = H(), o = F(n); { var i = s => { var a = H(), l = F(a); Y(l, () => t.presence ?? et, () => ({ present: r.isPresent })), O(s, a) }; dt(o, s => { (t.forceMount || t.open || r.isPresent) && s(i) }) } O(e, n), J() } var Dr, tr, Le, Ae, Cs, ci; class Lh { constructor(t) { y(this, Ae); y(this, Dr); y(this, tr); y(this, Le, !1); V(this, Dr, t), tn(() => it(this, Ae, Cs).call(this)) } run(t) { if (c(this, Le)) return; it(this, Ae, Cs).call(this), V(this, Le, !0); const r = c(this, Dr).ref.current; if (!r) { V(this, Le, !1); return } if (typeof r.getAnimations != "function") { it(this, Ae, ci).call(this, t); return } V(this, tr, window.requestAnimationFrame(() => { const n = r.getAnimations(); if (n.length === 0) { it(this, Ae, ci).call(this, t); return } Promise.allSettled(n.map(o => o.finished)).then(() => { it(this, Ae, ci).call(this, t) }) })) } } Dr = new WeakMap, tr = new WeakMap, Le = new WeakMap, Ae = new WeakSet, Cs = function () { c(this, tr) && (window.cancelAnimationFrame(c(this, tr)), V(this, tr, void 0)), V(this, Le, !1) }, ci = function (t) { const r = () => { t(), V(this, Le, !1) }; c(this, Dr).afterTick ? Zo(r) : r() }; var me, Fn, Ln; class Bh { constructor(t) { y(this, me); y(this, Fn); y(this, Ln); V(this, me, t), V(this, Fn, t.enabled ?? !0), V(this, Ln, new Lh({ ref: c(this, me).ref, afterTick: c(this, me).open })), ft([() => c(this, me).open.current], ([r]) => { c(this, Fn) && c(this, Ln).run(() => { r === c(this, me).open.current && c(this, me).onComplete() }) }) } } me = new WeakMap, Fn = new WeakMap, Ln = new WeakMap; function zh(e, t) { var r = H(), n = F(r); ff(n, () => t.children, o => { var i = H(), s = F(i); Y(s, () => t.children ?? et), O(o, i) }), O(e, r) } const va = typeof document < "u", Ts = Wh(); function Wh() { var e, t; return va && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent)) } function vl(e) { return e instanceof HTMLElement } function Vh(e) { return e instanceof Element } function Hh(e) { return e !== null } const Uh = new $r("BitsConfig"); function jh() { const e = new Kh(null, {}); return Uh.getOr(e).opts } class Kh { constructor(t, r) { k(this, "opts"); const n = Gh(t, r); this.opts = { defaultPortalTo: n(o => o.defaultPortalTo), defaultLocale: n(o => o.defaultLocale) } } } function Gh(e, t) { return r => T.with(() => { var i, s; const o = (i = r(t)) == null ? void 0 : i.current; if (o !== void 0) return o; if (e !== null) return (s = r(e.opts)) == null ? void 0 : s.current }) } function qh(e, t) { return r => { const n = jh(); return T.with(() => { const o = r(); if (o !== void 0) return o; const i = e(n).current; return i !== void 0 ? i : t }) } } const Yh = qh(e => e.defaultPortalTo, "body"); function Xh(e, t) { Z(t, !0); const r = Yh(() => t.to), n = Sd(); let o = M(i); function i() { if (!va || t.disabled) return null; let d = null; return typeof r.current == "string" ? d = document.querySelector(r.current) : d = r.current, d } let s; function a() { s && (df(s), s = null) } ft([() => g(o), () => t.disabled], ([d, h]) => { if (!d || h) { a(); return } return s = Pc(zh, { target: d, props: { children: t.children }, context: n }), () => { a() } }); var l = H(), u = F(l); { var f = d => { var h = H(), p = F(h); Y(p, () => t.children ?? et), O(d, h) }; dt(u, d => { t.disabled && d(f) }) } O(e, l), J() } function Yc(e, t, r, n) { const o = Array.isArray(t) ? t : [t]; return o.forEach(i => e.addEventListener(i, r, n)), () => { o.forEach(i => e.removeEventListener(i, r, n)) } } function ml(e, t = 500) { let r = null; const n = (...o) => { r !== null && clearTimeout(r), r = setTimeout(() => { e(...o) }, t) }; return n.destroy = () => { r !== null && (clearTimeout(r), r = null) }, n } function Xc(e, t) { return e === t || e.contains(t) } function Zc(e) { return (e == null ? void 0 : e.ownerDocument) ?? document } function Zh(e, t) { const { clientX: r, clientY: n } = e, o = t.getBoundingClientRect(); return r < o.left || r > o.right || n < o.top || n > o.bottom } globalThis.bitsDismissableLayers ?? (globalThis.bitsDismissableLayers = new Map); var Fr, er, Be, Lr, Br, ze, Bn, be, Oi, qr, Jc, Ci, zr, Ti, ki, Ni, Ii, zn, Qc, Ri, Mi; const Ra = class Ra { constructor(t) { y(this, qr); k(this, "opts"); y(this, Fr); y(this, er); y(this, Be, { pointerdown: !1 }); y(this, Lr, !1); y(this, Br, !1); y(this, ze); y(this, Bn); y(this, be, gt); y(this, Oi, t => { t.defaultPrevented || this.opts.ref.current && Zo(() => { var r, n; !this.opts.ref.current || c(this, Ii).call(this, t.target) || t.target && !c(this, Br) && ((n = (r = c(this, Bn)).current) == null || n.call(r, t)) }) }); y(this, Ci, t => { let r = t; r.defaultPrevented && (r = bl(t)), c(this, Fr).current(t) }); y(this, zr, ml(t => { if (!this.opts.ref.current) { c(this, be).call(this); return } const r = this.opts.isValidEvent.current(t, this.opts.ref.current) || $h(t, this.opts.ref.current); if (!c(this, Lr) || it(this, qr, Qc).call(this) || !r) { c(this, be).call(this); return } let n = t; if (n.defaultPrevented && (n = bl(n)), c(this, er).current !== "close" && c(this, er).current !== "defer-otherwise-close") { c(this, be).call(this); return } t.pointerType === "touch" ? (c(this, be).call(this), V(this, be, Yc(c(this, ze), "click", c(this, Ci), { once: !0 }))) : c(this, Fr).current(n) }, 10)); y(this, Ti, t => { c(this, Be)[t.type] = !0 }); y(this, ki, t => { c(this, Be)[t.type] = !1 }); y(this, Ni, () => { this.opts.ref.current && V(this, Lr, Qh(this.opts.ref.current)) }); y(this, Ii, t => this.opts.ref.current ? Xc(this.opts.ref.current, t) : !1); y(this, zn, ml(() => { for (const t in c(this, Be)) c(this, Be)[t] = !1; V(this, Lr, !1) }, 20)); y(this, Ri, () => { V(this, Br, !0) }); y(this, Mi, () => { V(this, Br, !1) }); k(this, "props", { onfocuscapture: c(this, Ri), onblurcapture: c(this, Mi) }); this.opts = t, V(this, er, t.interactOutsideBehavior), V(this, Fr, t.onInteractOutside), V(this, Bn, t.onFocusOutside), yt(() => { V(this, ze, Zc(this.opts.ref.current)) }); let r = gt; const n = () => { c(this, zn).call(this), globalThis.bitsDismissableLayers.delete(this), c(this, zr).destroy(), r() }; ft([() => this.opts.enabled.current, () => this.opts.ref.current], () => { if (!(!this.opts.enabled.current || !this.opts.ref.current)) return pa(1, () => { this.opts.ref.current && (globalThis.bitsDismissableLayers.set(this, c(this, er)), r(), r = it(this, qr, Jc).call(this)) }), n }), tn(() => { c(this, zn).destroy(), globalThis.bitsDismissableLayers.delete(this), c(this, zr).destroy(), c(this, be).call(this), r() }) } static create(t) { return new Ra(t) } }; Fr = new WeakMap, er = new WeakMap, Be = new WeakMap, Lr = new WeakMap, Br = new WeakMap, ze = new WeakMap, Bn = new WeakMap, be = new WeakMap, Oi = new WeakMap, qr = new WeakSet, Jc = function () { return Pr(Tt(c(this, ze), "pointerdown", Pr(c(this, Ti), c(this, Ni)), { capture: !0 }), Tt(c(this, ze), "pointerdown", Pr(c(this, ki), c(this, zr))), Tt(c(this, ze), "focusin", c(this, Oi))) }, Ci = new WeakMap, zr = new WeakMap, Ti = new WeakMap, ki = new WeakMap, Ni = new WeakMap, Ii = new WeakMap, zn = new WeakMap, Qc = function () { return Object.values(c(this, Be)).some(Boolean) }, Ri = new WeakMap, Mi = new WeakMap; let ks = Ra; function Jh(e) { return e.findLast(([t, { current: r }]) => r === "close" || r === "ignore") } function Qh(e) { const t = [...globalThis.bitsDismissableLayers], r = Jh(t); if (r) return r[0].opts.ref.current === e; const [n] = t[0]; return n.opts.ref.current === e } function $h(e, t) { if ("button" in e && e.button > 0) return !1; const r = e.target; return Vh(r) ? Zc(r).documentElement.contains(r) && !Xc(t, r) && Zh(e, t) : !1 } function bl(e) { const t = e.currentTarget, r = e.target; let n; e instanceof PointerEvent ? n = new PointerEvent(e.type, e) : n = new PointerEvent("pointerdown", e); let o = !1; return new Proxy(n, { get: (s, a) => a === "currentTarget" ? t : a === "target" ? r : a === "preventDefault" ? () => { o = !0, typeof s.preventDefault == "function" && s.preventDefault() } : a === "defaultPrevented" ? o : a in s ? s[a] : e[a] }) } function tg(e, t) { Z(t, !0); let r = E(t, "interactOutsideBehavior", 3, "close"), n = E(t, "onInteractOutside", 3, gt), o = E(t, "onFocusOutside", 3, gt), i = E(t, "isValidEvent", 3, () => !1); const s = ks.create({ id: T.with(() => t.id), interactOutsideBehavior: T.with(() => r()), onInteractOutside: T.with(() => n()), enabled: T.with(() => t.enabled), onFocusOutside: T.with(() => o()), isValidEvent: T.with(() => i()), ref: t.ref }); var a = H(), l = F(a); Y(l, () => t.children ?? et, () => ({ props: s.props })), O(e, a), J() } globalThis.bitsEscapeLayers ?? (globalThis.bitsEscapeLayers = new Map); var Di, Fi; const Ma = class Ma { constructor(t) { k(this, "opts"); k(this, "domContext"); y(this, Di, () => Tt(this.domContext.getDocument(), "keydown", c(this, Fi), { passive: !1 })); y(this, Fi, t => { if (t.key !== Th || !eg(this)) return; const r = new KeyboardEvent(t.type, t); t.preventDefault(); const n = this.opts.escapeKeydownBehavior.current; n !== "close" && n !== "defer-otherwise-close" || this.opts.onEscapeKeydown.current(r) }); this.opts = t, this.domContext = new Jo(this.opts.ref); let r = gt; ft(() => t.enabled.current, n => (n && (globalThis.bitsEscapeLayers.set(this, t.escapeKeydownBehavior), r = c(this, Di).call(this)), () => { r(), globalThis.bitsEscapeLayers.delete(this) })) } static create(t) { return new Ma(t) } }; Di = new WeakMap, Fi = new WeakMap; let Ns = Ma; function eg(e) { const t = [...globalThis.bitsEscapeLayers], r = t.findLast(([o, { current: i }]) => i === "close" || i === "ignore"); if (r) return r[0] === e; const [n] = t[0]; return n === e } function rg(e, t) { Z(t, !0); let r = E(t, "escapeKeydownBehavior", 3, "close"), n = E(t, "onEscapeKeydown", 3, gt); Ns.create({ escapeKeydownBehavior: T.with(() => r()), onEscapeKeydown: T.with(() => n()), enabled: T.with(() => t.enabled), ref: t.ref }); var o = H(), i = F(o); Y(i, () => t.children ?? et), O(e, o), J() } var we, Wn; const Li = class Li { constructor() { y(this, we, T([])); y(this, Wn, new WeakMap) } static getInstance() { return this.instance || (this.instance = new Li), this.instance } register(t) { const r = this.getActive(); r && r !== t && r.pause(), c(this, we).current = c(this, we).current.filter(n => n !== t), c(this, we).current.unshift(t) } unregister(t) { c(this, we).current = c(this, we).current.filter(n => n !== t); const r = this.getActive(); r && r.resume() } getActive() { return c(this, we).current[0] } setFocusMemory(t, r) { c(this, Wn).set(t, r) } getFocusMemory(t) { return c(this, Wn).get(t) } isActiveScope(t) { return this.getActive() === t } }; we = new WeakMap, Wn = new WeakMap, k(Li, "instance"); let Is = Li;/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/var $c = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], Rs = $c.join(","), tu = typeof Element > "u", Kr = tu ? function () { } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, vi = !tu && Element.prototype.getRootNode ? function (e) { var t; return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e) } : function (e) { return e == null ? void 0 : e.ownerDocument }, mi = function e(t, r) { var n; r === void 0 && (r = !0); var o = t == null || (n = t.getAttribute) === null || n === void 0 ? void 0 : n.call(t, "inert"), i = o === "" || o === "true", s = i || r && t && e(t.parentNode); return s }, ng = function (t) { var r, n = t == null || (r = t.getAttribute) === null || r === void 0 ? void 0 : r.call(t, "contenteditable"); return n === "" || n === "true" }, eu = function (t, r, n) { if (mi(t)) return []; var o = Array.prototype.slice.apply(t.querySelectorAll(Rs)); return r && Kr.call(t, Rs) && o.unshift(t), o = o.filter(n), o }, ru = function e(t, r, n) { for (var o = [], i = Array.from(t); i.length;) { var s = i.shift(); if (!mi(s, !1)) if (s.tagName === "SLOT") { var a = s.assignedElements(), l = a.length ? a : s.children, u = e(l, !0, n); n.flatten ? o.push.apply(o, u) : o.push({ scopeParent: s, candidates: u }) } else { var f = Kr.call(s, Rs); f && n.filter(s) && (r || !t.includes(s)) && o.push(s); var d = s.shadowRoot || typeof n.getShadowRoot == "function" && n.getShadowRoot(s), h = !mi(d, !1) && (!n.shadowRootFilter || n.shadowRootFilter(s)); if (d && h) { var p = e(d === !0 ? s.children : d.children, !0, n); n.flatten ? o.push.apply(o, p) : o.push({ scopeParent: s, candidates: p }) } else i.unshift.apply(i, s.children) } } return o }, nu = function (t) { return !isNaN(parseInt(t.getAttribute("tabindex"), 10)) }, ou = function (t) { if (!t) throw new Error("No node provided"); return t.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || ng(t)) && !nu(t) ? 0 : t.tabIndex }, og = function (t, r) { var n = ou(t); return n < 0 && r && !nu(t) ? 0 : n }, ig = function (t, r) { return t.tabIndex === r.tabIndex ? t.documentOrder - r.documentOrder : t.tabIndex - r.tabIndex }, iu = function (t) { return t.tagName === "INPUT" }, sg = function (t) { return iu(t) && t.type === "hidden" }, ag = function (t) { var r = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function (n) { return n.tagName === "SUMMARY" }); return r }, lg = function (t, r) { for (var n = 0; n < t.length; n++)if (t[n].checked && t[n].form === r) return t[n] }, cg = function (t) { if (!t.name) return !0; var r = t.form || vi(t), n = function (a) { return r.querySelectorAll('input[type="radio"][name="' + a + '"]') }, o; if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function") o = n(window.CSS.escape(t.name)); else try { o = n(t.name) } catch (s) { return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", s.message), !1 } var i = lg(o, t.form); return !i || i === t }, ug = function (t) { return iu(t) && t.type === "radio" }, dg = function (t) { return ug(t) && !cg(t) }, fg = function (t) { var r, n = t && vi(t), o = (r = n) === null || r === void 0 ? void 0 : r.host, i = !1; if (n && n !== t) { var s, a, l; for (i = !!((s = o) !== null && s !== void 0 && (a = s.ownerDocument) !== null && a !== void 0 && a.contains(o) || t != null && (l = t.ownerDocument) !== null && l !== void 0 && l.contains(t)); !i && o;) { var u, f, d; n = vi(o), o = (u = n) === null || u === void 0 ? void 0 : u.host, i = !!((f = o) !== null && f !== void 0 && (d = f.ownerDocument) !== null && d !== void 0 && d.contains(o)) } } return i }, wl = function (t) { var r = t.getBoundingClientRect(), n = r.width, o = r.height; return n === 0 && o === 0 }, hg = function (t, r) { var n = r.displayCheck, o = r.getShadowRoot; if (getComputedStyle(t).visibility === "hidden") return !0; var i = Kr.call(t, "details>summary:first-of-type"), s = i ? t.parentElement : t; if (Kr.call(s, "details:not([open]) *")) return !0; if (!n || n === "full" || n === "legacy-full") { if (typeof o == "function") { for (var a = t; t;) { var l = t.parentElement, u = vi(t); if (l && !l.shadowRoot && o(l) === !0) return wl(t); t.assignedSlot ? t = t.assignedSlot : !l && u !== t.ownerDocument ? t = u.host : t = l } t = a } if (fg(t)) return !t.getClientRects().length; if (n !== "legacy-full") return !0 } else if (n === "non-zero-area") return wl(t); return !1 }, gg = function (t) { if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName)) for (var r = t.parentElement; r;) { if (r.tagName === "FIELDSET" && r.disabled) { for (var n = 0; n < r.children.length; n++) { var o = r.children.item(n); if (o.tagName === "LEGEND") return Kr.call(r, "fieldset[disabled] *") ? !0 : !o.contains(t) } return !0 } r = r.parentElement } return !1 }, bi = function (t, r) { return !(r.disabled || mi(r) || sg(r) || hg(r, t) || ag(r) || gg(r)) }, yl = function (t, r) { return !(dg(r) || ou(r) < 0 || !bi(t, r)) }, pg = function (t) { var r = parseInt(t.getAttribute("tabindex"), 10); return !!(isNaN(r) || r >= 0) }, vg = function e(t) { var r = [], n = []; return t.forEach(function (o, i) { var s = !!o.scopeParent, a = s ? o.scopeParent : o, l = og(a, s), u = s ? e(o.candidates) : a; l === 0 ? s ? r.push.apply(r, u) : r.push(a) : n.push({ documentOrder: i, tabIndex: l, item: o, isScope: s, content: u }) }), n.sort(ig).reduce(function (o, i) { return i.isScope ? o.push.apply(o, i.content) : o.push(i.content), o }, []).concat(r) }, mg = function (t, r) { r = r || {}; var n; return r.getShadowRoot ? n = ru([t], r.includeContainer, { filter: yl.bind(null, r), flatten: !1, getShadowRoot: r.getShadowRoot, shadowRootFilter: pg }) : n = eu(t, r.includeContainer, yl.bind(null, r)), vg(n) }, bg = function (t, r) { r = r || {}; var n; return r.getShadowRoot ? n = ru([t], r.includeContainer, { filter: bi.bind(null, r), flatten: !0, getShadowRoot: r.getShadowRoot }) : n = eu(t, r.includeContainer, bi.bind(null, r)), n }, wg = $c.concat("iframe").join(","), yg = function (t, r) { if (r = r || {}, !t) throw new Error("No node provided"); return Kr.call(t, wg) === !1 ? !1 : bi(r, t) }, We, Ct, Ht, rr, Ve, bt, su, au, lu, cu, Ds, ui, Fs; const Da = class Da { constructor(t) { y(this, bt); y(this, We, !1); y(this, Ct, null); y(this, Ht, Is.getInstance()); y(this, rr, []); y(this, Ve); V(this, Ve, t) } get paused() { return c(this, We) } pause() { V(this, We, !0) } resume() { V(this, We, !1) } mount(t) { c(this, Ct) && this.unmount(), V(this, Ct, t), c(this, Ht).register(this), it(this, bt, cu).call(this), it(this, bt, au).call(this) } unmount() { c(this, Ct) && (it(this, bt, su).call(this), it(this, bt, lu).call(this), c(this, Ht).unregister(this), V(this, Ct, null)) } static use(t) { let r = null; return ft([() => t.ref.current, () => t.enabled.current], ([n, o]) => { n && o ? (r || (r = new Da(t)), r.mount(n)) : r && (r.unmount(), r = null) }), tn(() => { r == null || r.unmount() }), { get props() { return { tabindex: -1 } } } } }; We = new WeakMap, Ct = new WeakMap, Ht = new WeakMap, rr = new WeakMap, Ve = new WeakMap, bt = new WeakSet, su = function () { for (const t of c(this, rr)) t(); V(this, rr, []) }, au = function () { if (!c(this, Ct)) return; const t = new CustomEvent("focusScope.onOpenAutoFocus", { bubbles: !1, cancelable: !0 }); c(this, Ve).onOpenAutoFocus.current(t), t.defaultPrevented || requestAnimationFrame(() => { if (!c(this, Ct)) return; const r = it(this, bt, ui).call(this); r ? (r.focus(), c(this, Ht).setFocusMemory(this, r)) : c(this, Ct).focus() }) }, lu = function () { const t = new CustomEvent("focusScope.onCloseAutoFocus", { bubbles: !1, cancelable: !0 }); if (c(this, Ve).onCloseAutoFocus.current(t), !t.defaultPrevented) { const r = document.activeElement; r && r !== document.body && r.focus() } }, cu = function () { if (!c(this, Ct) || !c(this, Ve).trap.current) return; const t = c(this, Ct), r = t.ownerDocument, n = s => { if (c(this, We) || !c(this, Ht).isActiveScope(this)) return; const a = s.target; if (!a) return; if (t.contains(a)) c(this, Ht).setFocusMemory(this, a); else { const u = c(this, Ht).getFocusMemory(this); if (u && t.contains(u) && yg(u)) s.preventDefault(), u.focus(); else { const f = it(this, bt, ui).call(this), d = it(this, bt, Fs).call(this)[0]; (f || d || t).focus() } } }, o = s => { if (!c(this, Ve).loop || c(this, We) || s.key !== "Tab" || !c(this, Ht).isActiveScope(this)) return; const a = it(this, bt, Ds).call(this); if (a.length < 2) return; const l = a[0], u = a[a.length - 1]; !s.shiftKey && r.activeElement === u ? (s.preventDefault(), l.focus()) : s.shiftKey && r.activeElement === l && (s.preventDefault(), u.focus()) }; c(this, rr).push(Tt(r, "focusin", n, { capture: !0 }), Tt(t, "keydown", o)); const i = new MutationObserver(() => { const s = c(this, Ht).getFocusMemory(this); if (s && !t.contains(s)) { const a = it(this, bt, ui).call(this), l = it(this, bt, Fs).call(this)[0], u = a || l; u ? (u.focus(), c(this, Ht).setFocusMemory(this, u)) : t.focus() } }); i.observe(t, { childList: !0, subtree: !0 }), c(this, rr).push(() => i.disconnect()) }, Ds = function () { return c(this, Ct) ? mg(c(this, Ct), { includeContainer: !1, getShadowRoot: !0 }) : [] }, ui = function () { return it(this, bt, Ds).call(this)[0] || null }, Fs = function () { return c(this, Ct) ? bg(c(this, Ct), { includeContainer: !1, getShadowRoot: !0 }) : [] }; let Ms = Da; function _g(e, t) { Z(t, !0); let r = E(t, "enabled", 3, !1), n = E(t, "trapFocus", 3, !1), o = E(t, "loop", 3, !1), i = E(t, "onCloseAutoFocus", 3, gt), s = E(t, "onOpenAutoFocus", 3, gt); const a = Ms.use({ enabled: T.with(() => r()), trap: T.with(() => n()), loop: o(), onCloseAutoFocus: T.with(() => i()), onOpenAutoFocus: T.with(() => s()), ref: t.ref }); var l = H(), u = F(l); Y(u, () => t.focusScope ?? et, () => ({ props: a.props })), O(e, l), J() } globalThis.bitsTextSelectionLayers ?? (globalThis.bitsTextSelectionLayers = new Map); var Wr, Bi, uu, zi, Vn; const Fa = class Fa { constructor(t) { y(this, Bi); k(this, "opts"); k(this, "domContext"); y(this, Wr, gt); y(this, zi, t => { const r = this.opts.ref.current, n = t.target; !vl(r) || !vl(n) || !this.opts.enabled.current || !Sg(this) || !yh(r, n) || (this.opts.onPointerDown.current(t), !t.defaultPrevented && V(this, Wr, xg(r, this.domContext.getDocument().body))) }); y(this, Vn, () => { c(this, Wr).call(this), V(this, Wr, gt) }); this.opts = t, this.domContext = new Jo(t.ref); let r = gt; ft(() => this.opts.enabled.current, n => (n && (globalThis.bitsTextSelectionLayers.set(this, this.opts.enabled), r(), r = it(this, Bi, uu).call(this)), () => { r(), c(this, Vn).call(this), globalThis.bitsTextSelectionLayers.delete(this) })) } static create(t) { return new Fa(t) } }; Wr = new WeakMap, Bi = new WeakSet, uu = function () { return Pr(Tt(this.domContext.getDocument(), "pointerdown", c(this, zi)), Tt(this.domContext.getDocument(), "pointerup", Ic(c(this, Vn), this.opts.onPointerUp.current))) }, zi = new WeakMap, Vn = new WeakMap; let Ls = Fa; const _l = e => e.style.userSelect || e.style.webkitUserSelect; function xg(e, t) { const r = _l(t), n = _l(e); return ni(t, "none"), ni(e, "text"), () => { ni(t, r), ni(e, n) } } function ni(e, t) { e.style.userSelect = t, e.style.webkitUserSelect = t } function Sg(e) { const t = [...globalThis.bitsTextSelectionLayers]; if (!t.length) return !1; const r = t.at(-1); return r ? r[0] === e : !1 } function Ag(e, t) { Z(t, !0); let r = E(t, "preventOverflowTextSelection", 3, !0), n = E(t, "onPointerDown", 3, gt), o = E(t, "onPointerUp", 3, gt); Ls.create({ id: T.with(() => t.id), onPointerDown: T.with(() => n()), onPointerUp: T.with(() => o()), enabled: T.with(() => t.enabled && r()), ref: t.ref }); var i = H(), s = F(i); Y(s, () => t.children ?? et), O(e, i), J() } globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = { current: 0 }); function ma(e = "bits") { return globalThis.bitsIdCounter.current++, `${e}-${globalThis.bitsIdCounter.current}` } var Hn, Vr, nr, or, Wi, du; class Pg { constructor(t) { y(this, Wi); y(this, Hn); y(this, Vr, 0); y(this, nr, X()); y(this, or); V(this, Hn, t) } get(...t) { return V(this, Vr, c(this, Vr) + 1), g(c(this, nr)) === void 0 && V(this, or, Rd(() => { N(c(this, nr), c(this, Hn).call(this, ...t), !0) })), yt(() => () => { it(this, Wi, du).call(this) }), g(c(this, nr)) } } Hn = new WeakMap, Vr = new WeakMap, nr = new WeakMap, or = new WeakMap, Wi = new WeakSet, du = function () { V(this, Vr, c(this, Vr) - 1), c(this, or) && c(this, Vr) <= 0 && (c(this, or).call(this), N(c(this, nr), void 0), V(this, or, void 0)) }; const Eg = new Pg(() => { const e = new Es, t = M(() => { for (const i of e.values()) if (i) return !0; return !1 }); let r = X(null), n = null; function o() { va && (document.body.setAttribute("style", g(r) ?? ""), document.body.style.removeProperty("--scrollbar-width"), Ts && (n == null || n())) } return ft(() => g(t), () => { if (!g(t)) return; N(r, document.body.getAttribute("style"), !0); const i = getComputedStyle(document.body), s = window.innerWidth - document.documentElement.clientWidth, l = { padding: Number.parseInt(i.paddingRight ?? "0", 10) + s, margin: Number.parseInt(i.marginRight ?? "0", 10) }; s > 0 && (document.body.style.paddingRight = `${l.padding}px`, document.body.style.marginRight = `${l.margin}px`, document.body.style.setProperty("--scrollbar-width", `${s}px`), document.body.style.overflow = "hidden"), Ts && (n = Yc(document, "touchmove", u => { u.target === document.documentElement && (u.touches.length > 1 || u.preventDefault()) }, { passive: !1 })), Zo(() => { document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden" }) }), tn(() => () => { n == null || n() }), { get map() { return e }, resetBodyStyle: o } }); var ir, Un, jn, Ut; class Og { constructor(t, r = () => null) { y(this, ir, ma()); y(this, Un); y(this, jn, () => null); y(this, Ut); k(this, "locked"); V(this, Un, t), V(this, jn, r), V(this, Ut, Eg.get()), c(this, Ut) && (c(this, Ut).map.set(c(this, ir), c(this, Un) ?? !1), this.locked = T.with(() => c(this, Ut).map.get(c(this, ir)) ?? !1, n => c(this, Ut).map.set(c(this, ir), n)), tn(() => { if (c(this, Ut).map.delete(c(this, ir)), Cg(c(this, Ut).map)) return; const n = c(this, jn).call(this); n === null ? requestAnimationFrame(() => c(this, Ut).resetBodyStyle()) : pa(n, () => c(this, Ut).resetBodyStyle()) })) } } ir = new WeakMap, Un = new WeakMap, jn = new WeakMap, Ut = new WeakMap; function Cg(e) { for (const [t, r] of e) if (r) return !0; return !1 } function xl(e, t) { Z(t, !0); let r = E(t, "preventScroll", 3, !0), n = E(t, "restoreScrollDelay", 3, null); r() && new Og(r(), () => n()), J() } function Tg(e, t, r = !0) { if (!(e.length === 0 || t < 0 || t >= e.length)) return e.length === 1 && t === 0 ? e[0] : t === e.length - 1 ? r ? e[0] : void 0 : e[t + 1] } function kg(e, t, r = !0) { if (!(e.length === 0 || t < 0 || t >= e.length)) return e.length === 1 && t === 0 ? e[0] : t === 0 ? r ? e[e.length - 1] : void 0 : e[t - 1] } function Ng(e, t, r, n = !0) { if (e.length === 0 || t < 0 || t >= e.length) return; let o = t + r; return n ? o = (o % e.length + e.length) % e.length : o = Math.max(0, Math.min(o, e.length - 1)), e[o] } function Ig(e, t, r, n = !0) { if (e.length === 0 || t < 0 || t >= e.length) return; let o = t - r; return n ? o = (o % e.length + e.length) % e.length : o = Math.max(0, Math.min(o, e.length - 1)), e[o] } function ba(e, t, r) { const n = t.toLowerCase(); if (n.endsWith(" ")) { const d = n.slice(0, -1); if (e.filter(w => w.toLowerCase().startsWith(d)).length <= 1) return ba(e, d, r); const p = r == null ? void 0 : r.toLowerCase(); if (p && p.startsWith(d) && p.charAt(d.length) === " " && t.trim() === d) return r; const v = e.filter(w => w.toLowerCase().startsWith(n)); if (v.length > 0) { const w = r ? e.indexOf(r) : -1; return Sl(v, Math.max(w, 0)).find(x => x !== r) || r } } const i = t.length > 1 && Array.from(t).every(d => d === t[0]) ? t[0] : t, s = i.toLowerCase(), a = r ? e.indexOf(r) : -1; let l = Sl(e, Math.max(a, 0)); i.length === 1 && (l = l.filter(d => d !== r)); const f = l.find(d => d == null ? void 0 : d.toLowerCase().startsWith(s)); return f !== r ? f : void 0 } function Sl(e, t) { return e.map((r, n) => e[(t + n) % e.length]) } var Rg = rt("<input/>"), Mg = rt("<input/>"); function Dg(e, t) { Z(t, !0); let r = E(t, "value", 15), n = ct(t, ["$$slots", "$$events", "$$legacy", "value"]); const o = M(() => Yt(n, { "aria-hidden": "true", tabindex: -1, style: oh })); var i = H(), s = F(i); { var a = u => { var f = Rg(); mt(f, () => ({ ...g(o), value: r() })), O(u, f) }, l = u => { var f = Mg(); mt(f, () => ({ ...g(o) })), Of(f, r), O(u, f) }; dt(s, u => { g(o).type === "checkbox" ? u(a) : u(l, !1) }) } O(e, i), J() } const Fg = ["top", "right", "bottom", "left"], Ye = Math.min, Lt = Math.max, wi = Math.round, oi = Math.floor, ie = e => ({ x: e, y: e }), Lg = { left: "right", right: "left", bottom: "top", top: "bottom" }, Bg = { start: "end", end: "start" }; function Bs(e, t, r) { return Lt(e, Ye(t, r)) } function Ee(e, t) { return typeof e == "function" ? e(t) : e } function Oe(e) { return e.split("-")[0] } function rn(e) { return e.split("-")[1] } function wa(e) { return e === "x" ? "y" : "x" } function ya(e) { return e === "y" ? "height" : "width" } function ne(e) { return ["top", "bottom"].includes(Oe(e)) ? "y" : "x" } function _a(e) { return wa(ne(e)) } function zg(e, t, r) { r === void 0 && (r = !1); const n = rn(e), o = _a(e), i = ya(o); let s = o === "x" ? n === (r ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top"; return t.reference[i] > t.floating[i] && (s = yi(s)), [s, yi(s)] } function Wg(e) { const t = yi(e); return [zs(e), t, zs(t)] } function zs(e) { return e.replace(/start|end/g, t => Bg[t]) } function Vg(e, t, r) { const n = ["left", "right"], o = ["right", "left"], i = ["top", "bottom"], s = ["bottom", "top"]; switch (e) { case "top": case "bottom": return r ? t ? o : n : t ? n : o; case "left": case "right": return t ? i : s; default: return [] } } function Hg(e, t, r, n) { const o = rn(e); let i = Vg(Oe(e), r === "start", n); return o && (i = i.map(s => s + "-" + o), t && (i = i.concat(i.map(zs)))), i } function yi(e) { return e.replace(/left|right|bottom|top/g, t => Lg[t]) } function Ug(e) { return { top: 0, right: 0, bottom: 0, left: 0, ...e } } function fu(e) { return typeof e != "number" ? Ug(e) : { top: e, right: e, bottom: e, left: e } } function _i(e) { const { x: t, y: r, width: n, height: o } = e; return { width: n, height: o, top: r, left: t, right: t + n, bottom: r + o, x: t, y: r } } function Al(e, t, r) { let { reference: n, floating: o } = e; const i = ne(t), s = _a(t), a = ya(s), l = Oe(t), u = i === "y", f = n.x + n.width / 2 - o.width / 2, d = n.y + n.height / 2 - o.height / 2, h = n[a] / 2 - o[a] / 2; let p; switch (l) { case "top": p = { x: f, y: n.y - o.height }; break; case "bottom": p = { x: f, y: n.y + n.height }; break; case "right": p = { x: n.x + n.width, y: d }; break; case "left": p = { x: n.x - o.width, y: d }; break; default: p = { x: n.x, y: n.y } }switch (rn(t)) { case "start": p[s] -= h * (r && u ? -1 : 1); break; case "end": p[s] += h * (r && u ? -1 : 1); break }return p } const jg = async (e, t, r) => { const { placement: n = "bottom", strategy: o = "absolute", middleware: i = [], platform: s } = r, a = i.filter(Boolean), l = await (s.isRTL == null ? void 0 : s.isRTL(t)); let u = await s.getElementRects({ reference: e, floating: t, strategy: o }), { x: f, y: d } = Al(u, n, l), h = n, p = {}, v = 0; for (let w = 0; w < a.length; w++) { const { name: _, fn: S } = a[w], { x, y: b, data: m, reset: A } = await S({ x: f, y: d, initialPlacement: n, placement: h, strategy: o, middlewareData: p, rects: u, platform: s, elements: { reference: e, floating: t } }); f = x ?? f, d = b ?? d, p = { ...p, [_]: { ...p[_], ...m } }, A && v <= 50 && (v++, typeof A == "object" && (A.placement && (h = A.placement), A.rects && (u = A.rects === !0 ? await s.getElementRects({ reference: e, floating: t, strategy: o }) : A.rects), { x: f, y: d } = Al(u, h, l)), w = -1) } return { x: f, y: d, placement: h, strategy: o, middlewareData: p } }; async function En(e, t) { var r; t === void 0 && (t = {}); const { x: n, y: o, platform: i, rects: s, elements: a, strategy: l } = e, { boundary: u = "clippingAncestors", rootBoundary: f = "viewport", elementContext: d = "floating", altBoundary: h = !1, padding: p = 0 } = Ee(t, e), v = fu(p), _ = a[h ? d === "floating" ? "reference" : "floating" : d], S = _i(await i.getClippingRect({ element: (r = await (i.isElement == null ? void 0 : i.isElement(_))) == null || r ? _ : _.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)), boundary: u, rootBoundary: f, strategy: l })), x = d === "floating" ? { x: n, y: o, width: s.floating.width, height: s.floating.height } : s.reference, b = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)), m = await (i.isElement == null ? void 0 : i.isElement(b)) ? await (i.getScale == null ? void 0 : i.getScale(b)) || { x: 1, y: 1 } : { x: 1, y: 1 }, A = _i(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: a, rect: x, offsetParent: b, strategy: l }) : x); return { top: (S.top - A.top + v.top) / m.y, bottom: (A.bottom - S.bottom + v.bottom) / m.y, left: (S.left - A.left + v.left) / m.x, right: (A.right - S.right + v.right) / m.x } } const Kg = e => ({ name: "arrow", options: e, async fn(t) { const { x: r, y: n, placement: o, rects: i, platform: s, elements: a, middlewareData: l } = t, { element: u, padding: f = 0 } = Ee(e, t) || {}; if (u == null) return {}; const d = fu(f), h = { x: r, y: n }, p = _a(o), v = ya(p), w = await s.getDimensions(u), _ = p === "y", S = _ ? "top" : "left", x = _ ? "bottom" : "right", b = _ ? "clientHeight" : "clientWidth", m = i.reference[v] + i.reference[p] - h[p] - i.floating[v], A = h[p] - i.reference[p], I = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u)); let P = I ? I[b] : 0; (!P || !await (s.isElement == null ? void 0 : s.isElement(I))) && (P = a.floating[b] || i.floating[v]); const C = m / 2 - A / 2, W = P / 2 - w[v] / 2 - 1, q = Ye(d[S], W), j = Ye(d[x], W), K = q, z = P - w[v] - j, R = P / 2 - w[v] / 2 + C, U = Bs(K, R, z), $ = !l.arrow && rn(o) != null && R !== U && i.reference[v] / 2 - (R < K ? q : j) - w[v] / 2 < 0, tt = $ ? R < K ? R - K : R - z : 0; return { [p]: h[p] + tt, data: { [p]: U, centerOffset: R - U - tt, ...$ && { alignmentOffset: tt } }, reset: $ } } }), Gg = function (e) { return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) { var r, n; const { placement: o, middlewareData: i, rects: s, initialPlacement: a, platform: l, elements: u } = t, { mainAxis: f = !0, crossAxis: d = !0, fallbackPlacements: h, fallbackStrategy: p = "bestFit", fallbackAxisSideDirection: v = "none", flipAlignment: w = !0, ..._ } = Ee(e, t); if ((r = i.arrow) != null && r.alignmentOffset) return {}; const S = Oe(o), x = ne(a), b = Oe(a) === a, m = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), A = h || (b || !w ? [yi(a)] : Wg(a)), I = v !== "none"; !h && I && A.push(...Hg(a, w, v, m)); const P = [a, ...A], C = await En(t, _), W = []; let q = ((n = i.flip) == null ? void 0 : n.overflows) || []; if (f && W.push(C[S]), d) { const R = zg(o, s, m); W.push(C[R[0]], C[R[1]]) } if (q = [...q, { placement: o, overflows: W }], !W.every(R => R <= 0)) { var j, K; const R = (((j = i.flip) == null ? void 0 : j.index) || 0) + 1, U = P[R]; if (U && (!(d === "alignment" ? x !== ne(U) : !1) || q.every(D => D.overflows[0] > 0 && ne(D.placement) === x))) return { data: { index: R, overflows: q }, reset: { placement: U } }; let $ = (K = q.filter(tt => tt.overflows[0] <= 0).sort((tt, D) => tt.overflows[1] - D.overflows[1])[0]) == null ? void 0 : K.placement; if (!$) switch (p) { case "bestFit": { var z; const tt = (z = q.filter(D => { if (I) { const Et = ne(D.placement); return Et === x || Et === "y" } return !0 }).map(D => [D.placement, D.overflows.filter(Et => Et > 0).reduce((Et, vr) => Et + vr, 0)]).sort((D, Et) => D[1] - Et[1])[0]) == null ? void 0 : z[0]; tt && ($ = tt); break } case "initialPlacement": $ = a; break }if (o !== $) return { reset: { placement: $ } } } return {} } } }; function Pl(e, t) { return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width } } function El(e) { return Fg.some(t => e[t] >= 0) } const qg = function (e) { return e === void 0 && (e = {}), { name: "hide", options: e, async fn(t) { const { rects: r } = t, { strategy: n = "referenceHidden", ...o } = Ee(e, t); switch (n) { case "referenceHidden": { const i = await En(t, { ...o, elementContext: "reference" }), s = Pl(i, r.reference); return { data: { referenceHiddenOffsets: s, referenceHidden: El(s) } } } case "escaped": { const i = await En(t, { ...o, altBoundary: !0 }), s = Pl(i, r.floating); return { data: { escapedOffsets: s, escaped: El(s) } } } default: return {} } } } }; async function Yg(e, t) { const { placement: r, platform: n, elements: o } = e, i = await (n.isRTL == null ? void 0 : n.isRTL(o.floating)), s = Oe(r), a = rn(r), l = ne(r) === "y", u = ["left", "top"].includes(s) ? -1 : 1, f = i && l ? -1 : 1, d = Ee(t, e); let { mainAxis: h, crossAxis: p, alignmentAxis: v } = typeof d == "number" ? { mainAxis: d, crossAxis: 0, alignmentAxis: null } : { mainAxis: d.mainAxis || 0, crossAxis: d.crossAxis || 0, alignmentAxis: d.alignmentAxis }; return a && typeof v == "number" && (p = a === "end" ? v * -1 : v), l ? { x: p * f, y: h * u } : { x: h * u, y: p * f } } const Xg = function (e) { return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) { var r, n; const { x: o, y: i, placement: s, middlewareData: a } = t, l = await Yg(t, e); return s === ((r = a.offset) == null ? void 0 : r.placement) && (n = a.arrow) != null && n.alignmentOffset ? {} : { x: o + l.x, y: i + l.y, data: { ...l, placement: s } } } } }, Zg = function (e) { return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) { const { x: r, y: n, placement: o } = t, { mainAxis: i = !0, crossAxis: s = !1, limiter: a = { fn: _ => { let { x: S, y: x } = _; return { x: S, y: x } } }, ...l } = Ee(e, t), u = { x: r, y: n }, f = await En(t, l), d = ne(Oe(o)), h = wa(d); let p = u[h], v = u[d]; if (i) { const _ = h === "y" ? "top" : "left", S = h === "y" ? "bottom" : "right", x = p + f[_], b = p - f[S]; p = Bs(x, p, b) } if (s) { const _ = d === "y" ? "top" : "left", S = d === "y" ? "bottom" : "right", x = v + f[_], b = v - f[S]; v = Bs(x, v, b) } const w = a.fn({ ...t, [h]: p, [d]: v }); return { ...w, data: { x: w.x - r, y: w.y - n, enabled: { [h]: i, [d]: s } } } } } }, Jg = function (e) { return e === void 0 && (e = {}), { options: e, fn(t) { const { x: r, y: n, placement: o, rects: i, middlewareData: s } = t, { offset: a = 0, mainAxis: l = !0, crossAxis: u = !0 } = Ee(e, t), f = { x: r, y: n }, d = ne(o), h = wa(d); let p = f[h], v = f[d]; const w = Ee(a, t), _ = typeof w == "number" ? { mainAxis: w, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...w }; if (l) { const b = h === "y" ? "height" : "width", m = i.reference[h] - i.floating[b] + _.mainAxis, A = i.reference[h] + i.reference[b] - _.mainAxis; p < m ? p = m : p > A && (p = A) } if (u) { var S, x; const b = h === "y" ? "width" : "height", m = ["top", "left"].includes(Oe(o)), A = i.reference[d] - i.floating[b] + (m && ((S = s.offset) == null ? void 0 : S[d]) || 0) + (m ? 0 : _.crossAxis), I = i.reference[d] + i.reference[b] + (m ? 0 : ((x = s.offset) == null ? void 0 : x[d]) || 0) - (m ? _.crossAxis : 0); v < A ? v = A : v > I && (v = I) } return { [h]: p, [d]: v } } } }, Qg = function (e) { return e === void 0 && (e = {}), { name: "size", options: e, async fn(t) { var r, n; const { placement: o, rects: i, platform: s, elements: a } = t, { apply: l = () => { }, ...u } = Ee(e, t), f = await En(t, u), d = Oe(o), h = rn(o), p = ne(o) === "y", { width: v, height: w } = i.floating; let _, S; d === "top" || d === "bottom" ? (_ = d, S = h === (await (s.isRTL == null ? void 0 : s.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (S = d, _ = h === "end" ? "top" : "bottom"); const x = w - f.top - f.bottom, b = v - f.left - f.right, m = Ye(w - f[_], x), A = Ye(v - f[S], b), I = !t.middlewareData.shift; let P = m, C = A; if ((r = t.middlewareData.shift) != null && r.enabled.x && (C = b), (n = t.middlewareData.shift) != null && n.enabled.y && (P = x), I && !h) { const q = Lt(f.left, 0), j = Lt(f.right, 0), K = Lt(f.top, 0), z = Lt(f.bottom, 0); p ? C = v - 2 * (q !== 0 || j !== 0 ? q + j : Lt(f.left, f.right)) : P = w - 2 * (K !== 0 || z !== 0 ? K + z : Lt(f.top, f.bottom)) } await l({ ...t, availableWidth: C, availableHeight: P }); const W = await s.getDimensions(a.floating); return v !== W.width || w !== W.height ? { reset: { rects: !0 } } : {} } } }; function es() { return typeof window < "u" } function nn(e) { return hu(e) ? (e.nodeName || "").toLowerCase() : "#document" } function zt(e) { var t; return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window } function ue(e) { var t; return (t = (hu(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement } function hu(e) { return es() ? e instanceof Node || e instanceof zt(e).Node : !1 } function Jt(e) { return es() ? e instanceof Element || e instanceof zt(e).Element : !1 } function le(e) { return es() ? e instanceof HTMLElement || e instanceof zt(e).HTMLElement : !1 } function Ol(e) { return !es() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof zt(e).ShadowRoot } function Qo(e) { const { overflow: t, overflowX: r, overflowY: n, display: o } = Qt(e); return /auto|scroll|overlay|hidden|clip/.test(t + n + r) && !["inline", "contents"].includes(o) } function $g(e) { return ["table", "td", "th"].includes(nn(e)) } function rs(e) { return [":popover-open", ":modal"].some(t => { try { return e.matches(t) } catch { return !1 } }) } function xa(e) { const t = Sa(), r = Jt(e) ? Qt(e) : e; return ["transform", "translate", "scale", "rotate", "perspective"].some(n => r[n] ? r[n] !== "none" : !1) || (r.containerType ? r.containerType !== "normal" : !1) || !t && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !t && (r.filter ? r.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some(n => (r.willChange || "").includes(n)) || ["paint", "layout", "strict", "content"].some(n => (r.contain || "").includes(n)) } function tp(e) { let t = Xe(e); for (; le(t) && !Gr(t);) { if (xa(t)) return t; if (rs(t)) return null; t = Xe(t) } return null } function Sa() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } function Gr(e) { return ["html", "body", "#document"].includes(nn(e)) } function Qt(e) { return zt(e).getComputedStyle(e) } function ns(e) { return Jt(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.scrollX, scrollTop: e.scrollY } } function Xe(e) { if (nn(e) === "html") return e; const t = e.assignedSlot || e.parentNode || Ol(e) && e.host || ue(e); return Ol(t) ? t.host : t } function gu(e) { const t = Xe(e); return Gr(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : le(t) && Qo(t) ? t : gu(t) } function On(e, t, r) { var n; t === void 0 && (t = []), r === void 0 && (r = !0); const o = gu(e), i = o === ((n = e.ownerDocument) == null ? void 0 : n.body), s = zt(o); if (i) { const a = Ws(s); return t.concat(s, s.visualViewport || [], Qo(o) ? o : [], a && r ? On(a) : []) } return t.concat(o, On(o, [], r)) } function Ws(e) { return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null } function pu(e) { const t = Qt(e); let r = parseFloat(t.width) || 0, n = parseFloat(t.height) || 0; const o = le(e), i = o ? e.offsetWidth : r, s = o ? e.offsetHeight : n, a = wi(r) !== i || wi(n) !== s; return a && (r = i, n = s), { width: r, height: n, $: a } } function Aa(e) { return Jt(e) ? e : e.contextElement } function Er(e) { const t = Aa(e); if (!le(t)) return ie(1); const r = t.getBoundingClientRect(), { width: n, height: o, $: i } = pu(t); let s = (i ? wi(r.width) : r.width) / n, a = (i ? wi(r.height) : r.height) / o; return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), { x: s, y: a } } const ep = ie(0); function vu(e) { const t = zt(e); return !Sa() || !t.visualViewport ? ep : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } } function rp(e, t, r) { return t === void 0 && (t = !1), !r || t && r !== zt(e) ? !1 : t } function dr(e, t, r, n) { t === void 0 && (t = !1), r === void 0 && (r = !1); const o = e.getBoundingClientRect(), i = Aa(e); let s = ie(1); t && (n ? Jt(n) && (s = Er(n)) : s = Er(e)); const a = rp(i, r, n) ? vu(i) : ie(0); let l = (o.left + a.x) / s.x, u = (o.top + a.y) / s.y, f = o.width / s.x, d = o.height / s.y; if (i) { const h = zt(i), p = n && Jt(n) ? zt(n) : n; let v = h, w = Ws(v); for (; w && n && p !== v;) { const _ = Er(w), S = w.getBoundingClientRect(), x = Qt(w), b = S.left + (w.clientLeft + parseFloat(x.paddingLeft)) * _.x, m = S.top + (w.clientTop + parseFloat(x.paddingTop)) * _.y; l *= _.x, u *= _.y, f *= _.x, d *= _.y, l += b, u += m, v = zt(w), w = Ws(v) } } return _i({ width: f, height: d, x: l, y: u }) } function Pa(e, t) { const r = ns(e).scrollLeft; return t ? t.left + r : dr(ue(e)).left + r } function mu(e, t, r) { r === void 0 && (r = !1); const n = e.getBoundingClientRect(), o = n.left + t.scrollLeft - (r ? 0 : Pa(e, n)), i = n.top + t.scrollTop; return { x: o, y: i } } function np(e) { let { elements: t, rect: r, offsetParent: n, strategy: o } = e; const i = o === "fixed", s = ue(n), a = t ? rs(t.floating) : !1; if (n === s || a && i) return r; let l = { scrollLeft: 0, scrollTop: 0 }, u = ie(1); const f = ie(0), d = le(n); if ((d || !d && !i) && ((nn(n) !== "body" || Qo(s)) && (l = ns(n)), le(n))) { const p = dr(n); u = Er(n), f.x = p.x + n.clientLeft, f.y = p.y + n.clientTop } const h = s && !d && !i ? mu(s, l, !0) : ie(0); return { width: r.width * u.x, height: r.height * u.y, x: r.x * u.x - l.scrollLeft * u.x + f.x + h.x, y: r.y * u.y - l.scrollTop * u.y + f.y + h.y } } function op(e) { return Array.from(e.getClientRects()) } function ip(e) { const t = ue(e), r = ns(e), n = e.ownerDocument.body, o = Lt(t.scrollWidth, t.clientWidth, n.scrollWidth, n.clientWidth), i = Lt(t.scrollHeight, t.clientHeight, n.scrollHeight, n.clientHeight); let s = -r.scrollLeft + Pa(e); const a = -r.scrollTop; return Qt(n).direction === "rtl" && (s += Lt(t.clientWidth, n.clientWidth) - o), { width: o, height: i, x: s, y: a } } function sp(e, t) { const r = zt(e), n = ue(e), o = r.visualViewport; let i = n.clientWidth, s = n.clientHeight, a = 0, l = 0; if (o) { i = o.width, s = o.height; const u = Sa(); (!u || u && t === "fixed") && (a = o.offsetLeft, l = o.offsetTop) } return { width: i, height: s, x: a, y: l } } function ap(e, t) { const r = dr(e, !0, t === "fixed"), n = r.top + e.clientTop, o = r.left + e.clientLeft, i = le(e) ? Er(e) : ie(1), s = e.clientWidth * i.x, a = e.clientHeight * i.y, l = o * i.x, u = n * i.y; return { width: s, height: a, x: l, y: u } } function Cl(e, t, r) { let n; if (t === "viewport") n = sp(e, r); else if (t === "document") n = ip(ue(e)); else if (Jt(t)) n = ap(t, r); else { const o = vu(e); n = { x: t.x - o.x, y: t.y - o.y, width: t.width, height: t.height } } return _i(n) } function bu(e, t) { const r = Xe(e); return r === t || !Jt(r) || Gr(r) ? !1 : Qt(r).position === "fixed" || bu(r, t) } function lp(e, t) { const r = t.get(e); if (r) return r; let n = On(e, [], !1).filter(a => Jt(a) && nn(a) !== "body"), o = null; const i = Qt(e).position === "fixed"; let s = i ? Xe(e) : e; for (; Jt(s) && !Gr(s);) { const a = Qt(s), l = xa(s); !l && a.position === "fixed" && (o = null), (i ? !l && !o : !l && a.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || Qo(s) && !l && bu(e, s)) ? n = n.filter(f => f !== s) : o = a, s = Xe(s) } return t.set(e, n), n } function cp(e) { let { element: t, boundary: r, rootBoundary: n, strategy: o } = e; const s = [...r === "clippingAncestors" ? rs(t) ? [] : lp(t, this._c) : [].concat(r), n], a = s[0], l = s.reduce((u, f) => { const d = Cl(t, f, o); return u.top = Lt(d.top, u.top), u.right = Ye(d.right, u.right), u.bottom = Ye(d.bottom, u.bottom), u.left = Lt(d.left, u.left), u }, Cl(t, a, o)); return { width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top } } function up(e) { const { width: t, height: r } = pu(e); return { width: t, height: r } } function dp(e, t, r) { const n = le(t), o = ue(t), i = r === "fixed", s = dr(e, !0, i, t); let a = { scrollLeft: 0, scrollTop: 0 }; const l = ie(0); function u() { l.x = Pa(o) } if (n || !n && !i) if ((nn(t) !== "body" || Qo(o)) && (a = ns(t)), n) { const p = dr(t, !0, i, t); l.x = p.x + t.clientLeft, l.y = p.y + t.clientTop } else o && u(); i && !n && o && u(); const f = o && !n && !i ? mu(o, a) : ie(0), d = s.left + a.scrollLeft - l.x - f.x, h = s.top + a.scrollTop - l.y - f.y; return { x: d, y: h, width: s.width, height: s.height } } function ps(e) { return Qt(e).position === "static" } function Tl(e, t) { if (!le(e) || Qt(e).position === "fixed") return null; if (t) return t(e); let r = e.offsetParent; return ue(e) === r && (r = r.ownerDocument.body), r } function wu(e, t) { const r = zt(e); if (rs(e)) return r; if (!le(e)) { let o = Xe(e); for (; o && !Gr(o);) { if (Jt(o) && !ps(o)) return o; o = Xe(o) } return r } let n = Tl(e, t); for (; n && $g(n) && ps(n);)n = Tl(n, t); return n && Gr(n) && ps(n) && !xa(n) ? r : n || tp(e) || r } const fp = async function (e) { const t = this.getOffsetParent || wu, r = this.getDimensions, n = await r(e.floating); return { reference: dp(e.reference, await t(e.floating), e.strategy), floating: { x: 0, y: 0, width: n.width, height: n.height } } }; function hp(e) { return Qt(e).direction === "rtl" } const gp = { convertOffsetParentRelativeRectToViewportRelativeRect: np, getDocumentElement: ue, getClippingRect: cp, getOffsetParent: wu, getElementRects: fp, getClientRects: op, getDimensions: up, getScale: Er, isElement: Jt, isRTL: hp }; function yu(e, t) { return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height } function pp(e, t) { let r = null, n; const o = ue(e); function i() { var a; clearTimeout(n), (a = r) == null || a.disconnect(), r = null } function s(a, l) { a === void 0 && (a = !1), l === void 0 && (l = 1), i(); const u = e.getBoundingClientRect(), { left: f, top: d, width: h, height: p } = u; if (a || t(), !h || !p) return; const v = oi(d), w = oi(o.clientWidth - (f + h)), _ = oi(o.clientHeight - (d + p)), S = oi(f), b = { rootMargin: -v + "px " + -w + "px " + -_ + "px " + -S + "px", threshold: Lt(0, Ye(1, l)) || 1 }; let m = !0; function A(I) { const P = I[0].intersectionRatio; if (P !== l) { if (!m) return s(); P ? s(!1, P) : n = setTimeout(() => { s(!1, 1e-7) }, 1e3) } P === 1 && !yu(u, e.getBoundingClientRect()) && s(), m = !1 } try { r = new IntersectionObserver(A, { ...b, root: o.ownerDocument }) } catch { r = new IntersectionObserver(A, b) } r.observe(e) } return s(!0), i } function vp(e, t, r, n) { n === void 0 && (n = {}); const { ancestorScroll: o = !0, ancestorResize: i = !0, elementResize: s = typeof ResizeObserver == "function", layoutShift: a = typeof IntersectionObserver == "function", animationFrame: l = !1 } = n, u = Aa(e), f = o || i ? [...u ? On(u) : [], ...On(t)] : []; f.forEach(S => { o && S.addEventListener("scroll", r, { passive: !0 }), i && S.addEventListener("resize", r) }); const d = u && a ? pp(u, r) : null; let h = -1, p = null; s && (p = new ResizeObserver(S => { let [x] = S; x && x.target === u && p && (p.unobserve(t), cancelAnimationFrame(h), h = requestAnimationFrame(() => { var b; (b = p) == null || b.observe(t) })), r() }), u && !l && p.observe(u), p.observe(t)); let v, w = l ? dr(e) : null; l && _(); function _() { const S = dr(e); w && !yu(w, S) && r(), w = S, v = requestAnimationFrame(_) } return r(), () => { var S; f.forEach(x => { o && x.removeEventListener("scroll", r), i && x.removeEventListener("resize", r) }), d == null || d(), (S = p) == null || S.disconnect(), p = null, l && cancelAnimationFrame(v) } } const mp = Xg, bp = Zg, wp = Gg, yp = Qg, _p = qg, xp = Kg, Sp = Jg, Ap = (e, t, r) => { const n = new Map, o = { platform: gp, ...r }, i = { ...o.platform, _c: n }; return jg(e, t, { ...o, platform: i }) }; function Qe(e) { return typeof e == "function" ? e() : e } function _u(e) { return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1 } function kl(e, t) { const r = _u(e); return Math.round(t * r) / r } function Pp(e) { return { [`--bits-${e}-content-transform-origin`]: "var(--bits-floating-transform-origin)", [`--bits-${e}-content-available-width`]: "var(--bits-floating-available-width)", [`--bits-${e}-content-available-height`]: "var(--bits-floating-available-height)", [`--bits-${e}-anchor-width`]: "var(--bits-floating-anchor-width)", [`--bits-${e}-anchor-height`]: "var(--bits-floating-anchor-height)" } } function Ep(e) { const t = e.whileElementsMounted, r = M(() => Qe(e.open) ?? !0), n = M(() => Qe(e.middleware)), o = M(() => Qe(e.transform) ?? !0), i = M(() => Qe(e.placement) ?? "bottom"), s = M(() => Qe(e.strategy) ?? "absolute"), a = M(() => Qe(e.sideOffset) ?? 0), l = M(() => Qe(e.alignOffset) ?? 0), u = e.reference; let f = X(0), d = X(0); const h = T(null); let p = X(Kt(g(s))), v = X(Kt(g(i))), w = X(Kt({})), _ = X(!1); const S = M(() => { const P = h.current ? kl(h.current, g(f)) : g(f), C = h.current ? kl(h.current, g(d)) : g(d); return g(o) ? { position: g(p), left: "0", top: "0", transform: `translate(${P}px, ${C}px)`, ...h.current && _u(h.current) >= 1.5 && { willChange: "transform" } } : { position: g(p), left: `${P}px`, top: `${C}px` } }); let x; function b() { u.current === null || h.current === null || Ap(u.current, h.current, { middleware: g(n), placement: g(i), strategy: g(s) }).then(P => { if (!g(r) && g(f) !== 0 && g(d) !== 0) { const C = Math.max(Math.abs(g(a)), Math.abs(g(l)), 15); if (P.x <= C && P.y <= C) return } N(f, P.x, !0), N(d, P.y, !0), N(p, P.strategy, !0), N(v, P.placement, !0), N(w, P.middlewareData, !0), N(_, !0) }) } function m() { typeof x == "function" && (x(), x = void 0) } function A() { if (m(), t === void 0) { b(); return } u.current === null || h.current === null || (x = t(u.current, h.current, b)) } function I() { g(r) || N(_, !1) } return yt(b), yt(A), yt(I), yt(() => m), { floating: h, reference: u, get strategy() { return g(p) }, get placement() { return g(v) }, get middlewareData() { return g(w) }, get isPositioned() { return g(_) }, get floatingStyles() { return g(S) }, get update() { return b } } } const Op = { top: "bottom", right: "left", bottom: "top", left: "right" }, Ea = new $r("Floating.Root"), Nl = new $r("Floating.Content"), Oa = new $r("Floating.Root"); class xi { constructor() { k(this, "anchorNode", T(null)); k(this, "customAnchorNode", T(null)); k(this, "triggerNode", T(null)); yt(() => { this.customAnchorNode.current ? typeof this.customAnchorNode.current == "string" ? this.anchorNode.current = document.querySelector(this.customAnchorNode.current) : this.anchorNode.current = this.customAnchorNode.current : this.anchorNode.current = this.triggerNode.current }) } static create(t = !1) { return t ? Oa.set(new xi) : Ea.set(new xi) } } var Kn, Vi, Gn, Hi, qn, Ui, Yn, Xn, Zn, Jn, Qn, $n, to, eo, ro, no, oo, io, so, ao, lo, co, uo, fo; const ji = class ji { constructor(t, r) { k(this, "opts"); k(this, "root"); k(this, "contentRef", T(null)); k(this, "wrapperRef", T(null)); k(this, "arrowRef", T(null)); k(this, "contentAttachment", Ge(this.contentRef)); k(this, "wrapperAttachment", Ge(this.wrapperRef)); k(this, "arrowAttachment", Ge(this.arrowRef)); k(this, "arrowId", T(ma())); y(this, Kn, M(() => { if (typeof this.opts.style == "string") return pn(this.opts.style); if (!this.opts.style) return {} })); y(this, Vi); y(this, Gn, new hh(() => this.arrowRef.current ?? void 0)); y(this, Hi, M(() => { var t; return ((t = c(this, Gn)) == null ? void 0 : t.width) ?? 0 })); y(this, qn, M(() => { var t; return ((t = c(this, Gn)) == null ? void 0 : t.height) ?? 0 })); y(this, Ui, M(() => { var t; return ((t = this.opts.side) == null ? void 0 : t.current) + (this.opts.align.current !== "center" ? `-${this.opts.align.current}` : "") })); y(this, Yn, M(() => Array.isArray(this.opts.collisionBoundary.current) ? this.opts.collisionBoundary.current : [this.opts.collisionBoundary.current])); y(this, Xn, M(() => g(c(this, Yn)).length > 0)); y(this, Zn, M(() => ({ padding: this.opts.collisionPadding.current, boundary: g(c(this, Yn)).filter(Hh), altBoundary: this.hasExplicitBoundaries }))); y(this, Jn, X(void 0)); y(this, Qn, X(void 0)); y(this, $n, X(void 0)); y(this, to, X(void 0)); y(this, eo, M(() => [mp({ mainAxis: this.opts.sideOffset.current + g(c(this, qn)), alignmentAxis: this.opts.alignOffset.current }), this.opts.avoidCollisions.current && bp({ mainAxis: !0, crossAxis: !1, limiter: this.opts.sticky.current === "partial" ? Sp() : void 0, ...this.detectOverflowOptions }), this.opts.avoidCollisions.current && wp({ ...this.detectOverflowOptions }), yp({ ...this.detectOverflowOptions, apply: ({ rects: t, availableWidth: r, availableHeight: n }) => { const { width: o, height: i } = t.reference; N(c(this, Jn), r, !0), N(c(this, Qn), n, !0), N(c(this, $n), o, !0), N(c(this, to), i, !0) } }), this.arrowRef.current && xp({ element: this.arrowRef.current, padding: this.opts.arrowPadding.current }), Cp({ arrowWidth: g(c(this, Hi)), arrowHeight: g(c(this, qn)) }), this.opts.hideWhenDetached.current && _p({ strategy: "referenceHidden", ...this.detectOverflowOptions })].filter(Boolean))); k(this, "floating"); y(this, ro, M(() => Tp(this.floating.placement))); y(this, no, M(() => kp(this.floating.placement))); y(this, oo, M(() => { var t; return ((t = this.floating.middlewareData.arrow) == null ? void 0 : t.x) ?? 0 })); y(this, io, M(() => { var t; return ((t = this.floating.middlewareData.arrow) == null ? void 0 : t.y) ?? 0 })); y(this, so, M(() => { var t; return ((t = this.floating.middlewareData.arrow) == null ? void 0 : t.centerOffset) !== 0 })); y(this, ao, X()); y(this, lo, M(() => Op[this.placedSide])); y(this, co, M(() => { var t, r, n; return { id: this.opts.wrapperId.current, "data-bits-floating-content-wrapper": "", style: { ...this.floating.floatingStyles, transform: this.floating.isPositioned ? this.floating.floatingStyles.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: this.contentZIndex, "--bits-floating-transform-origin": `${(t = this.floating.middlewareData.transformOrigin) == null ? void 0 : t.x} ${(r = this.floating.middlewareData.transformOrigin) == null ? void 0 : r.y}`, "--bits-floating-available-width": `${g(c(this, Jn))}px`, "--bits-floating-available-height": `${g(c(this, Qn))}px`, "--bits-floating-anchor-width": `${g(c(this, $n))}px`, "--bits-floating-anchor-height": `${g(c(this, to))}px`, ...((n = this.floating.middlewareData.hide) == null ? void 0 : n.referenceHidden) && { visibility: "hidden", "pointer-events": "none" }, ...g(c(this, Kn)) }, dir: this.opts.dir.current, ...this.wrapperAttachment } })); y(this, uo, M(() => ({ "data-side": this.placedSide, "data-align": this.placedAlign, style: ga({ ...g(c(this, Kn)) }), ...this.contentAttachment }))); y(this, fo, M(() => ({ position: "absolute", left: this.arrowX ? `${this.arrowX}px` : void 0, top: this.arrowY ? `${this.arrowY}px` : void 0, [this.arrowBaseSide]: 0, "transform-origin": { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[this.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[this.placedSide], visibility: this.cannotCenterArrow ? "hidden" : void 0 }))); this.opts = t, this.root = r, t.customAnchor && (this.root.customAnchorNode.current = t.customAnchor.current), ft(() => t.customAnchor.current, n => { this.root.customAnchorNode.current = n }), this.floating = Ep({ strategy: () => this.opts.strategy.current, placement: () => g(c(this, Ui)), middleware: () => this.middleware, reference: this.root.anchorNode, whileElementsMounted: (...n) => { var i; return vp(...n, { animationFrame: ((i = c(this, Vi)) == null ? void 0 : i.current) === "always" }) }, open: () => this.opts.enabled.current, sideOffset: () => this.opts.sideOffset.current, alignOffset: () => this.opts.alignOffset.current }), yt(() => { var n; this.floating.isPositioned && ((n = this.opts.onPlaced) == null || n.current()) }), ft(() => this.contentRef.current, n => { if (!n) return; const o = Wc(n); this.contentZIndex = o.getComputedStyle(n).zIndex }), yt(() => { this.floating.floating.current = this.wrapperRef.current }) } static create(t, r = !1) { return r ? Nl.set(new ji(t, Oa.get())) : Nl.set(new ji(t, Ea.get())) } get hasExplicitBoundaries() { return g(c(this, Xn)) } set hasExplicitBoundaries(t) { N(c(this, Xn), t) } get detectOverflowOptions() { return g(c(this, Zn)) } set detectOverflowOptions(t) { N(c(this, Zn), t) } get middleware() { return g(c(this, eo)) } set middleware(t) { N(c(this, eo), t) } get placedSide() { return g(c(this, ro)) } set placedSide(t) { N(c(this, ro), t) } get placedAlign() { return g(c(this, no)) } set placedAlign(t) { N(c(this, no), t) } get arrowX() { return g(c(this, oo)) } set arrowX(t) { N(c(this, oo), t) } get arrowY() { return g(c(this, io)) } set arrowY(t) { N(c(this, io), t) } get cannotCenterArrow() { return g(c(this, so)) } set cannotCenterArrow(t) { N(c(this, so), t) } get contentZIndex() { return g(c(this, ao)) } set contentZIndex(t) { N(c(this, ao), t, !0) } get arrowBaseSide() { return g(c(this, lo)) } set arrowBaseSide(t) { N(c(this, lo), t) } get wrapperProps() { return g(c(this, co)) } set wrapperProps(t) { N(c(this, co), t) } get props() { return g(c(this, uo)) } set props(t) { N(c(this, uo), t) } get arrowStyle() { return g(c(this, fo)) } set arrowStyle(t) { N(c(this, fo), t) } }; Kn = new WeakMap, Vi = new WeakMap, Gn = new WeakMap, Hi = new WeakMap, qn = new WeakMap, Ui = new WeakMap, Yn = new WeakMap, Xn = new WeakMap, Zn = new WeakMap, Jn = new WeakMap, Qn = new WeakMap, $n = new WeakMap, to = new WeakMap, eo = new WeakMap, ro = new WeakMap, no = new WeakMap, oo = new WeakMap, io = new WeakMap, so = new WeakMap, ao = new WeakMap, lo = new WeakMap, co = new WeakMap, uo = new WeakMap, fo = new WeakMap; let Vs = ji; class Si { constructor(t, r) { k(this, "opts"); k(this, "root"); this.opts = t, this.root = r, t.virtualEl && t.virtualEl.current ? r.triggerNode = T.from(t.virtualEl.current) : r.triggerNode = t.ref } static create(t, r = !1) { return r ? new Si(t, Oa.get()) : new Si(t, Ea.get()) } } function Cp(e) { return { name: "transformOrigin", options: e, fn(t) { var _, S, x; const { placement: r, rects: n, middlewareData: o } = t, s = ((_ = o.arrow) == null ? void 0 : _.centerOffset) !== 0, a = s ? 0 : e.arrowWidth, l = s ? 0 : e.arrowHeight, [u, f] = Ca(r), d = { start: "0%", center: "50%", end: "100%" }[f], h = (((S = o.arrow) == null ? void 0 : S.x) ?? 0) + a / 2, p = (((x = o.arrow) == null ? void 0 : x.y) ?? 0) + l / 2; let v = "", w = ""; return u === "bottom" ? (v = s ? d : `${h}px`, w = `${-l}px`) : u === "top" ? (v = s ? d : `${h}px`, w = `${n.floating.height + l}px`) : u === "right" ? (v = `${-l}px`, w = s ? d : `${p}px`) : u === "left" && (v = `${n.floating.width + l}px`, w = s ? d : `${p}px`), { data: { x: v, y: w } } } } } function Ca(e) { const [t, r = "center"] = e.split("-"); return [t, r] } function Tp(e) { return Ca(e)[0] } function kp(e) { return Ca(e)[1] } function Np(e, t) { Z(t, !0); let r = E(t, "tooltip", 3, !1); xi.create(r()); var n = H(), o = F(n); Y(o, () => t.children ?? et), O(e, n), J() } const Ip = { afterMs: 1e4, onChange: gt }; function xu(e, t) { const { afterMs: r, onChange: n, getWindow: o } = { ...Ip, ...t }; let i = null, s = X(Kt(e)); function a() { return o().setTimeout(() => { N(s, e, !0), n == null || n(e) }, r) } return yt(() => () => { i && o().clearTimeout(i) }), T.with(() => g(s), l => { N(s, l, !0), n == null || n(l), i && o().clearTimeout(i), i = a() }) } var ye, sr, He; class Rp { constructor(t) { y(this, ye); y(this, sr, M(() => c(this, ye).candidateValues())); y(this, He); V(this, ye, t), V(this, He, xu("", { afterMs: 1e3, getWindow: c(this, ye).getWindow })), this.handleTypeaheadSearch = this.handleTypeaheadSearch.bind(this), this.resetTypeahead = this.resetTypeahead.bind(this) } handleTypeaheadSearch(t) { if (!c(this, ye).enabled() || !g(c(this, sr)).length) return; c(this, He).current = c(this, He).current + t; const r = c(this, ye).getCurrentItem(), n = g(c(this, sr)).find(a => a === r) ?? "", o = g(c(this, sr)).map(a => a ?? ""), i = ba(o, c(this, He).current, n), s = g(c(this, sr)).find(a => a === i); return s && c(this, ye).onMatch(s), s } resetTypeahead() { c(this, He).current = "" } } ye = new WeakMap, sr = new WeakMap, He = new WeakMap; var _e, xe, Ki, Gi; class Mp { constructor(t) { y(this, _e); y(this, xe); y(this, Ki, M(() => c(this, _e).onMatch ? c(this, _e).onMatch : t => t.focus())); y(this, Gi, M(() => c(this, _e).getCurrentItem ? c(this, _e).getCurrentItem : c(this, _e).getActiveElement)); V(this, _e, t), V(this, xe, xu("", { afterMs: 1e3, getWindow: t.getWindow })), this.handleTypeaheadSearch = this.handleTypeaheadSearch.bind(this), this.resetTypeahead = this.resetTypeahead.bind(this) } handleTypeaheadSearch(t, r) { var l, u; if (!r.length) return; c(this, xe).current = c(this, xe).current + t; const n = g(c(this, Gi))(), o = ((u = (l = r.find(f => f === n)) == null ? void 0 : l.textContent) == null ? void 0 : u.trim()) ?? "", i = r.map(f => { var d; return ((d = f.textContent) == null ? void 0 : d.trim()) ?? "" }), s = ba(i, c(this, xe).current, o), a = r.find(f => { var d; return ((d = f.textContent) == null ? void 0 : d.trim()) === s }); return a && g(c(this, Ki))(a), a } resetTypeahead() { c(this, xe).current = "" } get search() { return c(this, xe).current } } _e = new WeakMap, xe = new WeakMap, Ki = new WeakMap, Gi = new WeakMap; const Dp = [vn, Gc, jc], Fp = [Sr, Kc, Uc], Lp = [...Dp, ...Fp], Bp = Ch({ component: "select", parts: ["trigger", "content", "item", "viewport", "scroll-up-button", "scroll-down-button", "group", "group-label", "separator", "arrow", "input", "content-wrapper", "item-text", "value"] }), $o = new $r("Select.Root | Combobox.Root"), os = new $r("Select.Content | Combobox.Content"); var ho, go, po, vo, mo, bo, wo, yo, _o; class Su { constructor(t) { k(this, "opts"); y(this, ho, X(!1)); y(this, go, X(null)); y(this, po, X(null)); y(this, vo, X(null)); y(this, mo, X("")); y(this, bo, X(null)); y(this, wo, M(() => this.highlightedNode ? this.highlightedNode.getAttribute("data-value") : null)); y(this, yo, M(() => { if (this.highlightedNode) return this.highlightedNode.id })); y(this, _o, M(() => this.highlightedNode ? this.highlightedNode.getAttribute("data-label") : null)); k(this, "isUsingKeyboard", !1); k(this, "isCombobox", !1); k(this, "domContext", new Jo(() => null)); k(this, "getBitsAttr", t => Bp.getAttr(t, this.isCombobox ? "combobox" : void 0)); this.opts = t, this.isCombobox = t.isCombobox, new Bh({ ref: T.with(() => this.contentNode), open: this.opts.open, onComplete: () => { this.opts.onOpenChangeComplete.current(this.opts.open.current) } }), la(() => { this.opts.open.current || this.setHighlightedNode(null) }) } get touchedInput() { return g(c(this, ho)) } set touchedInput(t) { N(c(this, ho), t, !0) } get inputNode() { return g(c(this, go)) } set inputNode(t) { N(c(this, go), t, !0) } get contentNode() { return g(c(this, po)) } set contentNode(t) { N(c(this, po), t, !0) } get triggerNode() { return g(c(this, vo)) } set triggerNode(t) { N(c(this, vo), t, !0) } get valueId() { return g(c(this, mo)) } set valueId(t) { N(c(this, mo), t, !0) } get highlightedNode() { return g(c(this, bo)) } set highlightedNode(t) { N(c(this, bo), t, !0) } get highlightedValue() { return g(c(this, wo)) } set highlightedValue(t) { N(c(this, wo), t) } get highlightedId() { return g(c(this, yo)) } set highlightedId(t) { N(c(this, yo), t) } get highlightedLabel() { return g(c(this, _o)) } set highlightedLabel(t) { N(c(this, _o), t) } setHighlightedNode(t, r = !1) { this.highlightedNode = t, t && (this.isUsingKeyboard || r) && t.scrollIntoView({ block: this.opts.scrollAlignment.current }) } getCandidateNodes() { const t = this.contentNode; return t ? Array.from(t.querySelectorAll(`[${this.getBitsAttr("item")}]:not([data-disabled])`)) : [] } setHighlightedToFirstCandidate() { this.setHighlightedNode(null); const t = this.getCandidateNodes(); t.length && this.setHighlightedNode(t[0]) } getNodeByValue(t) { return this.getCandidateNodes().find(n => n.dataset.value === t) ?? null } setOpen(t) { this.opts.open.current = t } toggleOpen() { this.opts.open.current = !this.opts.open.current } handleOpen() { this.setOpen(!0) } handleClose() { this.setHighlightedNode(null), this.setOpen(!1) } toggleMenu() { this.toggleOpen() } } ho = new WeakMap, go = new WeakMap, po = new WeakMap, vo = new WeakMap, mo = new WeakMap, bo = new WeakMap, wo = new WeakMap, yo = new WeakMap, _o = new WeakMap; var xo, So, Ao, Po; class zp extends Su { constructor(r) { super(r); k(this, "opts"); k(this, "isMulti", !1); y(this, xo, M(() => this.opts.value.current !== "")); y(this, So, M(() => { var n; return this.opts.items.current.length ? ((n = this.opts.items.current.find(o => o.value === this.opts.value.current)) == null ? void 0 : n.label) ?? "" : "" })); y(this, Ao, M(() => this.opts.items.current.length ? this.opts.items.current.filter(n => !n.disabled).map(n => n.label) : [])); y(this, Po, M(() => !(this.isMulti || this.opts.items.current.length === 0))); this.opts = r, yt(() => { !this.opts.open.current && this.highlightedNode && this.setHighlightedNode(null) }), ft(() => this.opts.open.current, () => { this.opts.open.current && this.setInitialHighlightedNode() }) } get hasValue() { return g(c(this, xo)) } set hasValue(r) { N(c(this, xo), r) } get currentLabel() { return g(c(this, So)) } set currentLabel(r) { N(c(this, So), r) } get candidateLabels() { return g(c(this, Ao)) } set candidateLabels(r) { N(c(this, Ao), r) } get dataTypeaheadEnabled() { return g(c(this, Po)) } set dataTypeaheadEnabled(r) { N(c(this, Po), r) } includesItem(r) { return this.opts.value.current === r } toggleItem(r, n = r) { this.opts.value.current = this.includesItem(r) ? "" : r, this.opts.inputValue.current = n } setInitialHighlightedNode() { Zo(() => { if (this.highlightedNode && this.domContext.getDocument().contains(this.highlightedNode)) return; if (this.opts.value.current !== "") { const n = this.getNodeByValue(this.opts.value.current); if (n) { this.setHighlightedNode(n, !0); return } } const r = this.getCandidateNodes()[0]; r && this.setHighlightedNode(r, !0) }) } } xo = new WeakMap, So = new WeakMap, Ao = new WeakMap, Po = new WeakMap; var Eo; class Wp extends Su { constructor(r) { super(r); k(this, "opts"); k(this, "isMulti", !0); y(this, Eo, M(() => this.opts.value.current.length > 0)); this.opts = r, yt(() => { !this.opts.open.current && this.highlightedNode && this.setHighlightedNode(null) }), ft(() => this.opts.open.current, () => { this.opts.open.current && this.setInitialHighlightedNode() }) } get hasValue() { return g(c(this, Eo)) } set hasValue(r) { N(c(this, Eo), r) } includesItem(r) { return this.opts.value.current.includes(r) } toggleItem(r, n = r) { this.includesItem(r) ? this.opts.value.current = this.opts.value.current.filter(o => o !== r) : this.opts.value.current = [...this.opts.value.current, r], this.opts.inputValue.current = n } setInitialHighlightedNode() { Zo(() => { if (!this.domContext || this.highlightedNode && this.domContext.getDocument().contains(this.highlightedNode)) return; if (this.opts.value.current.length && this.opts.value.current[0] !== "") { const n = this.getNodeByValue(this.opts.value.current[0]); if (n) { this.setHighlightedNode(n, !0); return } } const r = this.getCandidateNodes()[0]; r && this.setHighlightedNode(r, !0) }) } } Eo = new WeakMap; class Vp { static create(t) { const { type: r, ...n } = t, o = r === "single" ? new zp(n) : new Wp(n); return $o.set(o) } } var ar, Hr, ce, Au, Us, js, Oo; const La = class La { constructor(t, r) { y(this, ce); k(this, "opts"); k(this, "root"); k(this, "attachment"); y(this, ar); y(this, Hr); y(this, Oo, M(() => ({ id: this.opts.id.current, disabled: this.root.opts.disabled.current ? !0 : void 0, "aria-haspopup": "listbox", "aria-expanded": Sh(this.root.opts.open.current), "aria-activedescendant": this.root.highlightedId, "data-state": Vc(this.root.opts.open.current), "data-disabled": Hc(this.root.opts.disabled.current), "data-placeholder": this.root.hasValue ? void 0 : "", [this.root.getBitsAttr("trigger")]: "", onpointerdown: this.onpointerdown, onkeydown: this.onkeydown, onclick: this.onclick, onpointerup: this.onpointerup, ...this.attachment }))); this.opts = t, this.root = r, this.attachment = Ge(t.ref, n => this.root.triggerNode = n), this.root.domContext = new Jo(t.ref), V(this, ar, new Mp({ getCurrentItem: () => this.root.highlightedNode, onMatch: n => { this.root.setHighlightedNode(n) }, getActiveElement: () => this.root.domContext.getActiveElement(), getWindow: () => this.root.domContext.getWindow() })), V(this, Hr, new Rp({ getCurrentItem: () => this.root.isMulti ? "" : this.root.currentLabel, onMatch: n => { if (this.root.isMulti || !this.root.opts.items.current) return; const o = this.root.opts.items.current.find(i => i.label === n); o && (this.root.opts.value.current = o.value) }, enabled: () => !this.root.isMulti && this.root.dataTypeaheadEnabled, candidateValues: () => this.root.isMulti ? [] : this.root.candidateLabels, getWindow: () => this.root.domContext.getWindow() })), this.onkeydown = this.onkeydown.bind(this), this.onpointerdown = this.onpointerdown.bind(this), this.onpointerup = this.onpointerup.bind(this), this.onclick = this.onclick.bind(this) } static create(t) { return new La(t, $o.get()) } onkeydown(t) { if (this.root.isUsingKeyboard = !0, (t.key === Sr || t.key === vn) && t.preventDefault(), !this.root.opts.open.current) { if (t.key === gl || t.key === gs || t.key === vn || t.key === Sr) t.preventDefault(), this.root.handleOpen(); else if (!this.root.isMulti && this.root.dataTypeaheadEnabled) { c(this, Hr).handleTypeaheadSearch(t.key); return } if (this.root.hasValue) return; const s = this.root.getCandidateNodes(); if (!s.length) return; if (t.key === vn) { const a = s[0]; this.root.setHighlightedNode(a) } else if (t.key === Sr) { const a = s[s.length - 1]; this.root.setHighlightedNode(a) } return } if (t.key === pl) { this.root.handleClose(); return } if ((t.key === gl || t.key === gs && c(this, ar).search === "") && !t.isComposing && (t.preventDefault(), it(this, ce, js).call(this))) return; if (t.key === Sr && t.altKey && this.root.handleClose(), Lp.includes(t.key)) { t.preventDefault(); const s = this.root.getCandidateNodes(), a = this.root.highlightedNode, l = a ? s.indexOf(a) : -1, u = this.root.opts.loop.current; let f; if (t.key === vn ? f = Tg(s, l, u) : t.key === Sr ? f = kg(s, l, u) : t.key === Kc ? f = Ng(s, l, 10, u) : t.key === Gc ? f = Ig(s, l, 10, u) : t.key === jc ? f = s[0] : t.key === Uc && (f = s[s.length - 1]), !f) return; this.root.setHighlightedNode(f); return } const r = t.ctrlKey || t.altKey || t.metaKey, n = t.key.length === 1, o = t.key === gs, i = this.root.getCandidateNodes(); if (t.key !== pl) { if (!r && (n || o)) { !c(this, ar).handleTypeaheadSearch(t.key, i) && o && (t.preventDefault(), it(this, ce, js).call(this)); return } this.root.highlightedNode || this.root.setHighlightedToFirstCandidate() } } onclick(t) { t.currentTarget.focus() } onpointerdown(t) { if (this.root.opts.disabled.current) return; if (t.pointerType === "touch") return t.preventDefault(); const r = t.target; r != null && r.hasPointerCapture(t.pointerId) && (r == null || r.releasePointerCapture(t.pointerId)), t.button === 0 && t.ctrlKey === !1 && (this.root.opts.open.current === !1 ? it(this, ce, Us).call(this, t) : this.root.handleClose()) } onpointerup(t) { this.root.opts.disabled.current || (t.preventDefault(), t.pointerType === "touch" && (this.root.opts.open.current === !1 ? it(this, ce, Us).call(this, t) : this.root.handleClose())) } get props() { return g(c(this, Oo)) } set props(t) { N(c(this, Oo), t) } }; ar = new WeakMap, Hr = new WeakMap, ce = new WeakSet, Au = function () { this.root.opts.open.current = !0, c(this, Hr).resetTypeahead(), c(this, ar).resetTypeahead() }, Us = function (t) { it(this, ce, Au).call(this) }, js = function () { const t = this.root.highlightedValue === this.root.opts.value.current; return !this.root.opts.allowDeselect.current && t && !this.root.isMulti ? (this.root.handleClose(), !0) : (this.root.highlightedValue !== null && this.root.toggleItem(this.root.highlightedValue, this.root.highlightedLabel ?? void 0), !this.root.isMulti && !t ? (this.root.handleClose(), !0) : !1) }, Oo = new WeakMap; let Hs = La; var Co, To, qi, ko, No; const Ba = class Ba { constructor(t, r) { k(this, "opts"); k(this, "root"); k(this, "attachment"); y(this, Co, X(null)); y(this, To, X(!1)); k(this, "domContext"); y(this, qi, M(() => Pp(this.root.isCombobox ? "combobox" : "select"))); k(this, "onInteractOutside", t => { if (t.target === this.root.triggerNode || t.target === this.root.inputNode) { t.preventDefault(); return } this.opts.onInteractOutside.current(t), !t.defaultPrevented && this.root.handleClose() }); k(this, "onEscapeKeydown", t => { this.opts.onEscapeKeydown.current(t), !t.defaultPrevented && this.root.handleClose() }); k(this, "onOpenAutoFocus", t => { t.preventDefault() }); k(this, "onCloseAutoFocus", t => { t.preventDefault() }); y(this, ko, M(() => ({ open: this.root.opts.open.current }))); y(this, No, M(() => ({ id: this.opts.id.current, role: "listbox", "aria-multiselectable": this.root.isMulti ? "true" : void 0, "data-state": Vc(this.root.opts.open.current), [this.root.getBitsAttr("content")]: "", style: { display: "flex", flexDirection: "column", outline: "none", boxSizing: "border-box", pointerEvents: "auto", ...g(c(this, qi)) }, onpointermove: this.onpointermove, ...this.attachment }))); k(this, "popperProps", { onInteractOutside: this.onInteractOutside, onEscapeKeydown: this.onEscapeKeydown, onOpenAutoFocus: this.onOpenAutoFocus, onCloseAutoFocus: this.onCloseAutoFocus, trapFocus: !1, loop: !1, onPlaced: () => { this.root.opts.open.current && (this.isPositioned = !0) } }); this.opts = t, this.root = r, this.attachment = Ge(t.ref, n => this.root.contentNode = n), this.domContext = new Jo(this.opts.ref), this.root.domContext === null && (this.root.domContext = this.domContext), tn(() => { this.root.contentNode = null, this.isPositioned = !1 }), ft(() => this.root.opts.open.current, () => { this.root.opts.open.current || (this.isPositioned = !1) }), this.onpointermove = this.onpointermove.bind(this) } static create(t) { return os.set(new Ba(t, $o.get())) } get viewportNode() { return g(c(this, Co)) } set viewportNode(t) { N(c(this, Co), t, !0) } get isPositioned() { return g(c(this, To)) } set isPositioned(t) { N(c(this, To), t, !0) } onpointermove(t) { this.root.isUsingKeyboard = !1 } get snippetProps() { return g(c(this, ko)) } set snippetProps(t) { N(c(this, ko), t) } get props() { return g(c(this, No)) } set props(t) { N(c(this, No), t) } }; Co = new WeakMap, To = new WeakMap, qi = new WeakMap, ko = new WeakMap, No = new WeakMap; let Ks = Ba; var Io, Ro, Mo, Do, Fo; const za = class za { constructor(t, r) { k(this, "opts"); k(this, "root"); k(this, "attachment"); y(this, Io, M(() => this.root.includesItem(this.opts.value.current))); y(this, Ro, M(() => this.root.highlightedValue === this.opts.value.current)); k(this, "prevHighlighted", new Lc(() => this.isHighlighted)); y(this, Mo, X(!1)); y(this, Do, M(() => ({ selected: this.isSelected, highlighted: this.isHighlighted }))); y(this, Fo, M(() => ({ id: this.opts.id.current, role: "option", "aria-selected": this.root.includesItem(this.opts.value.current) ? "true" : void 0, "data-value": this.opts.value.current, "data-disabled": Hc(this.opts.disabled.current), "data-highlighted": this.root.highlightedValue === this.opts.value.current && !this.opts.disabled.current ? "" : void 0, "data-selected": this.root.includesItem(this.opts.value.current) ? "" : void 0, "data-label": this.opts.label.current, [this.root.getBitsAttr("item")]: "", onpointermove: this.onpointermove, onpointerdown: this.onpointerdown, onpointerup: this.onpointerup, ...this.attachment }))); this.opts = t, this.root = r, this.attachment = Ge(t.ref), ft([() => this.isHighlighted, () => this.prevHighlighted.current], () => { this.isHighlighted ? this.opts.onHighlight.current() : this.prevHighlighted.current && this.opts.onUnhighlight.current() }), ft(() => this.mounted, () => { this.mounted && this.root.setInitialHighlightedNode() }), this.onpointerdown = this.onpointerdown.bind(this), this.onpointerup = this.onpointerup.bind(this), this.onpointermove = this.onpointermove.bind(this) } static create(t) { return new za(t, $o.get()) } get isSelected() { return g(c(this, Io)) } set isSelected(t) { N(c(this, Io), t) } get isHighlighted() { return g(c(this, Ro)) } set isHighlighted(t) { N(c(this, Ro), t) } get mounted() { return g(c(this, Mo)) } set mounted(t) { N(c(this, Mo), t, !0) } handleSelect() { if (this.opts.disabled.current) return; const t = this.opts.value.current === this.root.opts.value.current; if (!this.root.opts.allowDeselect.current && t && !this.root.isMulti) { this.root.handleClose(); return } this.root.toggleItem(this.opts.value.current, this.opts.label.current), !this.root.isMulti && !t && this.root.handleClose() } get snippetProps() { return g(c(this, Do)) } set snippetProps(t) { N(c(this, Do), t) } onpointerdown(t) { t.preventDefault() } onpointerup(t) { if (!(t.defaultPrevented || !this.opts.ref.current)) { if (t.pointerType === "touch" && !Ts) { Tt(this.opts.ref.current, "click", () => { this.handleSelect(), this.root.setHighlightedNode(this.opts.ref.current) }, { once: !0 }); return } t.preventDefault(), this.handleSelect(), t.pointerType === "touch" && this.root.setHighlightedNode(this.opts.ref.current) } } onpointermove(t) { t.pointerType !== "touch" && this.root.highlightedNode !== this.opts.ref.current && this.root.setHighlightedNode(this.opts.ref.current) } get props() { return g(c(this, Fo)) } set props(t) { N(c(this, Fo), t) } }; Io = new WeakMap, Ro = new WeakMap, Mo = new WeakMap, Do = new WeakMap, Fo = new WeakMap; let Gs = za; var Lo, Bo; const Wa = class Wa { constructor(t, r) { k(this, "opts"); k(this, "root"); y(this, Lo, M(() => this.root.opts.name.current !== "")); y(this, Bo, M(() => ({ disabled: Ph(this.root.opts.disabled.current), required: Eh(this.root.opts.required.current), name: this.root.opts.name.current, value: this.opts.value.current, onfocus: this.onfocus }))); this.opts = t, this.root = r, this.onfocus = this.onfocus.bind(this) } static create(t) { return new Wa(t, $o.get()) } get shouldRender() { return g(c(this, Lo)) } set shouldRender(t) { N(c(this, Lo), t) } onfocus(t) { var r, n; t.preventDefault(), this.root.isCombobox ? (n = this.root.inputNode) == null || n.focus() : (r = this.root.triggerNode) == null || r.focus() } get props() { return g(c(this, Bo)) } set props(t) { N(c(this, Bo), t) } }; Lo = new WeakMap, Bo = new WeakMap; let qs = Wa; var zo, Wo; const Va = class Va { constructor(t, r) { k(this, "opts"); k(this, "content"); k(this, "root"); k(this, "attachment"); y(this, zo, X(0)); y(this, Wo, M(() => ({ id: this.opts.id.current, role: "presentation", [this.root.getBitsAttr("viewport")]: "", style: { position: "relative", flex: 1, overflow: "auto" }, ...this.attachment }))); this.opts = t, this.content = r, this.root = r.root, this.attachment = Ge(t.ref, n => this.content.viewportNode = n) } static create(t) { return new Va(t, os.get()) } get prevScrollTop() { return g(c(this, zo)) } set prevScrollTop(t) { N(c(this, zo), t, !0) } get props() { return g(c(this, Wo)) } set props(t) { N(c(this, Wo), t) } }; zo = new WeakMap, Wo = new WeakMap; let Ys = Va; var Vo, Ho; class Pu { constructor(t, r) { k(this, "opts"); k(this, "content"); k(this, "root"); k(this, "attachment"); k(this, "autoScrollTimer", null); k(this, "userScrollTimer", -1); k(this, "isUserScrolling", !1); k(this, "onAutoScroll", gt); y(this, Vo, X(!1)); y(this, Ho, M(() => ({ id: this.opts.id.current, "aria-hidden": Ah(!0), style: { flexShrink: 0 }, onpointerdown: this.onpointerdown, onpointermove: this.onpointermove, onpointerleave: this.onpointerleave, ...this.attachment }))); this.opts = t, this.content = r, this.root = r.root, this.attachment = Ge(t.ref), ft([() => this.mounted], () => { if (!this.mounted) { this.isUserScrolling = !1; return } this.isUserScrolling }), yt(() => { this.mounted || this.clearAutoScrollInterval() }), this.onpointerdown = this.onpointerdown.bind(this), this.onpointermove = this.onpointermove.bind(this), this.onpointerleave = this.onpointerleave.bind(this) } get mounted() { return g(c(this, Vo)) } set mounted(t) { N(c(this, Vo), t, !0) } handleUserScroll() { this.content.domContext.clearTimeout(this.userScrollTimer), this.isUserScrolling = !0, this.userScrollTimer = this.content.domContext.setTimeout(() => { this.isUserScrolling = !1 }, 200) } clearAutoScrollInterval() { this.autoScrollTimer !== null && (this.content.domContext.clearTimeout(this.autoScrollTimer), this.autoScrollTimer = null) } onpointerdown(t) { if (this.autoScrollTimer !== null) return; const r = n => { this.onAutoScroll(), this.autoScrollTimer = this.content.domContext.setTimeout(() => r(n + 1), this.opts.delay.current(n)) }; this.autoScrollTimer = this.content.domContext.setTimeout(() => r(1), this.opts.delay.current(0)) } onpointermove(t) { this.onpointerdown(t) } onpointerleave(t) { this.clearAutoScrollInterval() } get props() { return g(c(this, Ho)) } set props(t) { N(c(this, Ho), t) } } Vo = new WeakMap, Ho = new WeakMap; var Uo, jo; const Ha = class Ha { constructor(t) { k(this, "scrollButtonState"); k(this, "content"); k(this, "root"); y(this, Uo, X(!1)); k(this, "scrollIntoViewTimer", null); k(this, "handleScroll", (t = !1) => { if (t || this.scrollButtonState.handleUserScroll(), !this.content.viewportNode) return; const r = this.content.viewportNode.scrollHeight - this.content.viewportNode.clientHeight, n = Number.parseInt(getComputedStyle(this.content.viewportNode).paddingTop, 10); this.canScrollDown = Math.ceil(this.content.viewportNode.scrollTop) < r - n }); k(this, "handleAutoScroll", () => { const t = this.content.viewportNode, r = this.root.highlightedNode; !t || !r || (t.scrollTop = t.scrollTop + r.offsetHeight) }); y(this, jo, M(() => ({ ...this.scrollButtonState.props, [this.root.getBitsAttr("scroll-down-button")]: "" }))); this.scrollButtonState = t, this.content = t.content, this.root = t.root, this.scrollButtonState.onAutoScroll = this.handleAutoScroll, ft([() => this.content.viewportNode, () => this.content.isPositioned], () => { if (!(!this.content.viewportNode || !this.content.isPositioned)) return this.handleScroll(!0), Tt(this.content.viewportNode, "scroll", () => this.handleScroll()) }), ft(() => this.scrollButtonState.mounted, () => { this.scrollButtonState.mounted && (this.scrollIntoViewTimer && clearTimeout(this.scrollIntoViewTimer), this.scrollIntoViewTimer = pa(5, () => { const r = this.root.highlightedNode; r == null || r.scrollIntoView({ block: this.root.opts.scrollAlignment.current }) })) }) } static create(t) { return new Ha(new Pu(t, os.get())) } get canScrollDown() { return g(c(this, Uo)) } set canScrollDown(t) { N(c(this, Uo), t, !0) } get props() { return g(c(this, jo)) } set props(t) { N(c(this, jo), t) } }; Uo = new WeakMap, jo = new WeakMap; let Xs = Ha; var Ko, Go; const Ua = class Ua { constructor(t) { k(this, "scrollButtonState"); k(this, "content"); k(this, "root"); y(this, Ko, X(!1)); k(this, "handleScroll", (t = !1) => { if (t || this.scrollButtonState.handleUserScroll(), !this.content.viewportNode) return; const r = Number.parseInt(getComputedStyle(this.content.viewportNode).paddingTop, 10); this.canScrollUp = this.content.viewportNode.scrollTop - r > .1 }); k(this, "handleAutoScroll", () => { !this.content.viewportNode || !this.root.highlightedNode || (this.content.viewportNode.scrollTop = this.content.viewportNode.scrollTop - this.root.highlightedNode.offsetHeight) }); y(this, Go, M(() => ({ ...this.scrollButtonState.props, [this.root.getBitsAttr("scroll-up-button")]: "" }))); this.scrollButtonState = t, this.content = t.content, this.root = t.root, this.scrollButtonState.onAutoScroll = this.handleAutoScroll, ft([() => this.content.viewportNode, () => this.content.isPositioned], () => { if (!(!this.content.viewportNode || !this.content.isPositioned)) return this.handleScroll(!0), Tt(this.content.viewportNode, "scroll", () => this.handleScroll()) }) } static create(t) { return new Ua(new Pu(t, os.get())) } get canScrollUp() { return g(c(this, Ko)) } set canScrollUp(t) { N(c(this, Ko), t, !0) } get props() { return g(c(this, Go)) } set props(t) { N(c(this, Go), t) } }; Ko = new WeakMap, Go = new WeakMap; let Zs = Ua; function Il(e, t) { Z(t, !0); let r = E(t, "value", 15, ""); const n = qs.create({ value: T.with(() => r()) }); var o = H(), i = F(o); { var s = a => { Dg(a, Mt(() => n.props, { get autocomplete() { return t.autocomplete }, get value() { return r() }, set value(l) { r(l) } })) }; dt(i, a => { n.shouldRender && a(s) }) } O(e, o), J() } function Hp(e, t) { Z(t, !0); let r = E(t, "tooltip", 3, !1); Si.create({ id: T.with(() => t.id), virtualEl: T.with(() => t.virtualEl), ref: t.ref }, r()); var n = H(), o = F(n); Y(o, () => t.children ?? et), O(e, n), J() } function Up(e, t) { Z(t, !0); let r = E(t, "side", 3, "bottom"), n = E(t, "sideOffset", 3, 0), o = E(t, "align", 3, "center"), i = E(t, "alignOffset", 3, 0), s = E(t, "arrowPadding", 3, 0), a = E(t, "avoidCollisions", 3, !0), l = E(t, "collisionBoundary", 19, () => []), u = E(t, "collisionPadding", 3, 0), f = E(t, "hideWhenDetached", 3, !1), d = E(t, "onPlaced", 3, () => { }), h = E(t, "sticky", 3, "partial"), p = E(t, "updatePositionStrategy", 3, "optimized"), v = E(t, "strategy", 3, "fixed"), w = E(t, "dir", 3, "ltr"), _ = E(t, "style", 19, () => ({})), S = E(t, "wrapperId", 19, ma), x = E(t, "customAnchor", 3, null), b = E(t, "tooltip", 3, !1); const m = Vs.create({ side: T.with(() => r()), sideOffset: T.with(() => n()), align: T.with(() => o()), alignOffset: T.with(() => i()), id: T.with(() => t.id), arrowPadding: T.with(() => s()), avoidCollisions: T.with(() => a()), collisionBoundary: T.with(() => l()), collisionPadding: T.with(() => u()), hideWhenDetached: T.with(() => f()), onPlaced: T.with(() => d()), sticky: T.with(() => h()), updatePositionStrategy: T.with(() => p()), strategy: T.with(() => v()), dir: T.with(() => w()), style: T.with(() => _()), enabled: T.with(() => t.enabled), wrapperId: T.with(() => S()), customAnchor: T.with(() => x()) }, b()), A = M(() => Yt(m.wrapperProps, { style: { pointerEvents: "auto" } })); var I = H(), P = F(I); Y(P, () => t.content ?? et, () => ({ props: m.props, wrapperProps: g(A) })), O(e, I), J() } function jp(e, t) { Z(t, !0), Nc(() => { var o; (o = t.onPlaced) == null || o.call(t) }); var r = H(), n = F(r); Y(n, () => t.content ?? et, () => ({ props: {}, wrapperProps: {} })), O(e, r), J() } function Kp(e, t) { let r = E(t, "isStatic", 3, !1), n = ct(t, ["$$slots", "$$events", "$$legacy", "content", "isStatic", "onPlaced"]); var o = H(), i = F(o); { var s = l => { jp(l, { get content() { return t.content }, get onPlaced() { return t.onPlaced } }) }, a = l => { Up(l, Mt({ get content() { return t.content }, get onPlaced() { return t.onPlaced } }, () => n)) }; dt(i, l => { r() ? l(s) : l(a, !1) }) } O(e, o) } var Gp = rt("<!> <!>", 1); function Eu(e, t) { Z(t, !0); let r = E(t, "interactOutsideBehavior", 3, "close"), n = E(t, "trapFocus", 3, !0), o = E(t, "isValidEvent", 3, () => !1), i = E(t, "customAnchor", 3, null), s = E(t, "isStatic", 3, !1), a = E(t, "tooltip", 3, !1), l = ct(t, ["$$slots", "$$events", "$$legacy", "popper", "onEscapeKeydown", "escapeKeydownBehavior", "preventOverflowTextSelection", "id", "onPointerDown", "onPointerUp", "side", "sideOffset", "align", "alignOffset", "arrowPadding", "avoidCollisions", "collisionBoundary", "collisionPadding", "sticky", "hideWhenDetached", "updatePositionStrategy", "strategy", "dir", "preventScroll", "wrapperId", "style", "onPlaced", "onInteractOutside", "onCloseAutoFocus", "onOpenAutoFocus", "onFocusOutside", "interactOutsideBehavior", "loop", "trapFocus", "isValidEvent", "customAnchor", "isStatic", "enabled", "ref", "tooltip"]); Kp(e, { get isStatic() { return s() }, get id() { return t.id }, get side() { return t.side }, get sideOffset() { return t.sideOffset }, get align() { return t.align }, get alignOffset() { return t.alignOffset }, get arrowPadding() { return t.arrowPadding }, get avoidCollisions() { return t.avoidCollisions }, get collisionBoundary() { return t.collisionBoundary }, get collisionPadding() { return t.collisionPadding }, get sticky() { return t.sticky }, get hideWhenDetached() { return t.hideWhenDetached }, get updatePositionStrategy() { return t.updatePositionStrategy }, get strategy() { return t.strategy }, get dir() { return t.dir }, get wrapperId() { return t.wrapperId }, get style() { return t.style }, get onPlaced() { return t.onPlaced }, get customAnchor() { return i() }, get enabled() { return t.enabled }, get tooltip() { return a() }, content: (f, d) => { let h = () => d == null ? void 0 : d().props, p = () => d == null ? void 0 : d().wrapperProps; var v = Gp(), w = F(v); { var _ = b => { xl(b, { get preventScroll() { return t.preventScroll } }) }, S = (b, m) => { { var A = I => { xl(I, { get preventScroll() { return t.preventScroll } }) }; dt(b, I => { t.forceMount || I(A) }, m) } }; dt(w, b => { t.forceMount && t.enabled ? b(_) : b(S, !1) }) } var x = G(w, 2); _g(x, { get onOpenAutoFocus() { return t.onOpenAutoFocus }, get onCloseAutoFocus() { return t.onCloseAutoFocus }, get loop() { return t.loop }, get enabled() { return t.enabled }, get trapFocus() { return n() }, get forceMount() { return t.forceMount }, get ref() { return t.ref }, focusScope: (m, A) => { let I = () => A == null ? void 0 : A().props; rg(m, { get onEscapeKeydown() { return t.onEscapeKeydown }, get escapeKeydownBehavior() { return t.escapeKeydownBehavior }, get enabled() { return t.enabled }, get ref() { return t.ref }, children: (P, C) => { { const W = (q, j) => { let K = () => j == null ? void 0 : j().props; Ag(q, { get id() { return t.id }, get preventOverflowTextSelection() { return t.preventOverflowTextSelection }, get onPointerDown() { return t.onPointerDown }, get onPointerUp() { return t.onPointerUp }, get enabled() { return t.enabled }, get ref() { return t.ref }, children: (z, R) => { var U = H(), $ = F(U), tt = re(() => ({ props: Yt(l, h(), K(), I(), { style: { pointerEvents: "auto" } }), wrapperProps: p() })); Y($, () => t.popper ?? et, () => g(tt)), O(z, U) }, $$slots: { default: !0 } }) }; tg(P, { get id() { return t.id }, get onInteractOutside() { return t.onInteractOutside }, get onFocusOutside() { return t.onFocusOutside }, get interactOutsideBehavior() { return r() }, isValidEvent: o(), get enabled() { return t.enabled }, get ref() { return t.ref }, children: W, $$slots: { default: !0 } }) } }, $$slots: { default: !0 } }) }, $$slots: { focusScope: !0 } }), O(f, v) }, $$slots: { content: !0 } }), J() } function qp(e, t) { let r = E(t, "interactOutsideBehavior", 3, "close"), n = E(t, "trapFocus", 3, !0), o = E(t, "isValidEvent", 3, () => !1), i = E(t, "customAnchor", 3, null), s = E(t, "isStatic", 3, !1), a = ct(t, ["$$slots", "$$events", "$$legacy", "popper", "open", "onEscapeKeydown", "escapeKeydownBehavior", "preventOverflowTextSelection", "id", "onPointerDown", "onPointerUp", "side", "sideOffset", "align", "alignOffset", "arrowPadding", "avoidCollisions", "collisionBoundary", "collisionPadding", "sticky", "hideWhenDetached", "updatePositionStrategy", "strategy", "dir", "preventScroll", "wrapperId", "style", "onPlaced", "onInteractOutside", "onCloseAutoFocus", "onOpenAutoFocus", "onFocusOutside", "interactOutsideBehavior", "loop", "trapFocus", "isValidEvent", "customAnchor", "isStatic", "ref"]); Fh(e, { get open() { return t.open }, get ref() { return t.ref }, presence: u => { Eu(u, Mt({ get popper() { return t.popper }, get onEscapeKeydown() { return t.onEscapeKeydown }, get escapeKeydownBehavior() { return t.escapeKeydownBehavior }, get preventOverflowTextSelection() { return t.preventOverflowTextSelection }, get id() { return t.id }, get onPointerDown() { return t.onPointerDown }, get onPointerUp() { return t.onPointerUp }, get side() { return t.side }, get sideOffset() { return t.sideOffset }, get align() { return t.align }, get alignOffset() { return t.alignOffset }, get arrowPadding() { return t.arrowPadding }, get avoidCollisions() { return t.avoidCollisions }, get collisionBoundary() { return t.collisionBoundary }, get collisionPadding() { return t.collisionPadding }, get sticky() { return t.sticky }, get hideWhenDetached() { return t.hideWhenDetached }, get updatePositionStrategy() { return t.updatePositionStrategy }, get strategy() { return t.strategy }, get dir() { return t.dir }, get preventScroll() { return t.preventScroll }, get wrapperId() { return t.wrapperId }, get style() { return t.style }, get onPlaced() { return t.onPlaced }, get customAnchor() { return i() }, get isStatic() { return s() }, get enabled() { return t.open }, get onInteractOutside() { return t.onInteractOutside }, get onCloseAutoFocus() { return t.onCloseAutoFocus }, get onOpenAutoFocus() { return t.onOpenAutoFocus }, get interactOutsideBehavior() { return r() }, get loop() { return t.loop }, get trapFocus() { return n() }, isValidEvent: o(), get onFocusOutside() { return t.onFocusOutside }, forceMount: !1, get ref() { return t.ref } }, () => a)) }, $$slots: { presence: !0 } }) } function Yp(e, t) { let r = E(t, "interactOutsideBehavior", 3, "close"), n = E(t, "trapFocus", 3, !0), o = E(t, "isValidEvent", 3, () => !1), i = E(t, "customAnchor", 3, null), s = E(t, "isStatic", 3, !1), a = ct(t, ["$$slots", "$$events", "$$legacy", "popper", "onEscapeKeydown", "escapeKeydownBehavior", "preventOverflowTextSelection", "id", "onPointerDown", "onPointerUp", "side", "sideOffset", "align", "alignOffset", "arrowPadding", "avoidCollisions", "collisionBoundary", "collisionPadding", "sticky", "hideWhenDetached", "updatePositionStrategy", "strategy", "dir", "preventScroll", "wrapperId", "style", "onPlaced", "onInteractOutside", "onCloseAutoFocus", "onOpenAutoFocus", "onFocusOutside", "interactOutsideBehavior", "loop", "trapFocus", "isValidEvent", "customAnchor", "isStatic", "enabled"]); Eu(e, Mt({ get popper() { return t.popper }, get onEscapeKeydown() { return t.onEscapeKeydown }, get escapeKeydownBehavior() { return t.escapeKeydownBehavior }, get preventOverflowTextSelection() { return t.preventOverflowTextSelection }, get id() { return t.id }, get onPointerDown() { return t.onPointerDown }, get onPointerUp() { return t.onPointerUp }, get side() { return t.side }, get sideOffset() { return t.sideOffset }, get align() { return t.align }, get alignOffset() { return t.alignOffset }, get arrowPadding() { return t.arrowPadding }, get avoidCollisions() { return t.avoidCollisions }, get collisionBoundary() { return t.collisionBoundary }, get collisionPadding() { return t.collisionPadding }, get sticky() { return t.sticky }, get hideWhenDetached() { return t.hideWhenDetached }, get updatePositionStrategy() { return t.updatePositionStrategy }, get strategy() { return t.strategy }, get dir() { return t.dir }, get preventScroll() { return t.preventScroll }, get wrapperId() { return t.wrapperId }, get style() { return t.style }, get onPlaced() { return t.onPlaced }, get customAnchor() { return i() }, get isStatic() { return s() }, get enabled() { return t.enabled }, get onInteractOutside() { return t.onInteractOutside }, get onCloseAutoFocus() { return t.onCloseAutoFocus }, get onOpenAutoFocus() { return t.onOpenAutoFocus }, get interactOutsideBehavior() { return r() }, get loop() { return t.loop }, get trapFocus() { return n() }, isValidEvent: o(), get onFocusOutside() { return t.onFocusOutside } }, () => a, { forceMount: !0 })) } var Xp = rt("<div><div><!></div></div>"), Zp = rt("<div><div><!></div></div>"); function Jp(e, t) { const r = Qr(); Z(t, !0); let n = E(t, "id", 19, () => en(r)), o = E(t, "ref", 15, null), i = E(t, "forceMount", 3, !1), s = E(t, "side", 3, "bottom"), a = E(t, "onInteractOutside", 3, gt), l = E(t, "onEscapeKeydown", 3, gt), u = E(t, "preventScroll", 3, !1), f = ct(t, ["$$slots", "$$events", "$$legacy", "id", "ref", "forceMount", "side", "onInteractOutside", "onEscapeKeydown", "children", "child", "preventScroll"]); const d = Ks.create({ id: T.with(() => n()), ref: T.with(() => o(), S => o(S)), onInteractOutside: T.with(() => a()), onEscapeKeydown: T.with(() => l()) }), h = M(() => Yt(f, d.props)); var p = H(), v = F(p); { var w = S => { Yp(S, Mt(() => g(h), () => d.popperProps, { get ref() { return d.opts.ref }, get side() { return s() }, get enabled() { return d.root.opts.open.current }, get id() { return n() }, get preventScroll() { return u() }, forceMount: !0, popper: (b, m) => { let A = () => m == null ? void 0 : m().props, I = () => m == null ? void 0 : m().wrapperProps; var P = H(); const C = M(() => Yt(A(), { style: d.props.style })); var W = F(P); { var q = K => { var z = H(), R = F(z), U = re(() => ({ props: g(C), wrapperProps: I(), ...d.snippetProps })); Y(R, () => t.child, () => g(U)), O(K, z) }, j = K => { var z = Xp(); mt(z, () => ({ ...I() })); var R = nt(z); mt(R, () => ({ ...g(C) })); var U = nt(R); Y(U, () => t.children ?? et), O(K, z) }; dt(W, K => { t.child ? K(q) : K(j, !1) }) } O(b, P) }, $$slots: { popper: !0 } })) }, _ = (S, x) => { { var b = m => { qp(m, Mt(() => g(h), () => d.popperProps, { get ref() { return d.opts.ref }, get side() { return s() }, get open() { return d.root.opts.open.current }, get id() { return n() }, get preventScroll() { return u() }, forceMount: !1, popper: (I, P) => { let C = () => P == null ? void 0 : P().props, W = () => P == null ? void 0 : P().wrapperProps; var q = H(); const j = M(() => Yt(C(), { style: d.props.style })); var K = F(q); { var z = U => { var $ = H(), tt = F($), D = re(() => ({ props: g(j), wrapperProps: W(), ...d.snippetProps })); Y(tt, () => t.child, () => g(D)), O(U, $) }, R = U => { var $ = Zp(); mt($, () => ({ ...W() })); var tt = nt($); mt(tt, () => ({ ...g(j) })); var D = nt(tt); Y(D, () => t.children ?? et), O(U, $) }; dt(K, U => { t.child ? U(z) : U(R, !1) }) } O(I, q) }, $$slots: { popper: !0 } })) }; dt(S, m => { i() || m(b) }, x) } }; dt(v, S => { i() ? S(w) : S(_, !1) }) } O(e, p), J() } function Ta(e, t) { Z(t, !0); let r = E(t, "mounted", 15, !1), n = E(t, "onMountedChange", 3, gt); gh(() => (r(!0), n()(!0), () => { r(!1), n()(!1) })), J() } var Qp = rt("<div><!></div>"), $p = rt("<!> <!>", 1); function tv(e, t) { const r = Qr(); Z(t, !0); let n = E(t, "id", 19, () => en(r)), o = E(t, "ref", 15, null), i = E(t, "label", 19, () => t.value), s = E(t, "disabled", 3, !1), a = E(t, "onHighlight", 3, gt), l = E(t, "onUnhighlight", 3, gt), u = ct(t, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "label", "disabled", "children", "child", "onHighlight", "onUnhighlight"]); const f = Gs.create({ id: T.with(() => n()), ref: T.with(() => o(), S => o(S)), value: T.with(() => t.value), disabled: T.with(() => s()), label: T.with(() => i()), onHighlight: T.with(() => a()), onUnhighlight: T.with(() => l()) }), d = M(() => Yt(u, f.props)); var h = $p(), p = F(h); { var v = S => { var x = H(), b = F(x), m = re(() => ({ props: g(d), ...f.snippetProps })); Y(b, () => t.child, () => g(m)), O(S, x) }, w = S => { var x = Qp(); mt(x, () => ({ ...g(d) })); var b = nt(x); Y(b, () => t.children ?? et, () => f.snippetProps), O(S, x) }; dt(p, S => { t.child ? S(v) : S(w, !1) }) } var _ = G(p, 2); Ta(_, { get mounted() { return f.mounted }, set mounted(S) { f.mounted = S } }), O(e, h), J() } var ev = rt("<div><!></div>"); function rv(e, t) { const r = Qr(); Z(t, !0); let n = E(t, "id", 19, () => en(r)), o = E(t, "ref", 15, null), i = ct(t, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]); const s = Ys.create({ id: T.with(() => n()), ref: T.with(() => o(), h => o(h)) }), a = M(() => Yt(i, s.props)); var l = H(), u = F(l); { var f = h => { var p = H(), v = F(p); Y(v, () => t.child, () => ({ props: g(a) })), O(h, p) }, d = h => { var p = ev(); mt(p, () => ({ ...g(a) })); var v = nt(p); Y(v, () => t.children ?? et), O(h, p) }; dt(u, h => { t.child ? h(f) : h(d, !1) }) } O(e, l), J() } var nv = rt("<div><!></div>"), ov = rt("<!> <!>", 1); function iv(e, t) { const r = Qr(); Z(t, !0); let n = E(t, "id", 19, () => en(r)), o = E(t, "ref", 15, null), i = E(t, "delay", 3, () => 50), s = ct(t, ["$$slots", "$$events", "$$legacy", "id", "ref", "delay", "child", "children"]); const a = Xs.create({ id: T.with(() => n()), ref: T.with(() => o(), h => o(h)), delay: T.with(() => i()) }), l = M(() => Yt(s, a.props)); var u = H(), f = F(u); { var d = h => { var p = ov(), v = F(p); Ta(v, { get mounted() { return a.scrollButtonState.mounted }, set mounted(x) { a.scrollButtonState.mounted = x } }); var w = G(v, 2); { var _ = x => { var b = H(), m = F(b); Y(m, () => t.child, () => ({ props: s })), O(x, b) }, S = x => { var b = nv(); mt(b, () => ({ ...g(l) })); var m = nt(b); Y(m, () => t.children ?? et), O(x, b) }; dt(w, x => { t.child ? x(_) : x(S, !1) }) } O(h, p) }; dt(f, h => { a.canScrollDown && h(d) }) } O(e, u), J() } var sv = rt("<div><!></div>"), av = rt("<!> <!>", 1); function lv(e, t) { const r = Qr(); Z(t, !0); let n = E(t, "id", 19, () => en(r)), o = E(t, "ref", 15, null), i = E(t, "delay", 3, () => 50), s = ct(t, ["$$slots", "$$events", "$$legacy", "id", "ref", "delay", "child", "children"]); const a = Zs.create({ id: T.with(() => n()), ref: T.with(() => o(), h => o(h)), delay: T.with(() => i()) }), l = M(() => Yt(s, a.props)); var u = H(), f = F(u); { var d = h => { var p = av(), v = F(p); Ta(v, { get mounted() { return a.scrollButtonState.mounted }, set mounted(x) { a.scrollButtonState.mounted = x } }); var w = G(v, 2); { var _ = x => { var b = H(), m = F(b); Y(m, () => t.child, () => ({ props: s })), O(x, b) }, S = x => { var b = sv(); mt(b, () => ({ ...g(l) })); var m = nt(b); Y(m, () => t.children ?? et), O(x, b) }; dt(w, x => { t.child ? x(_) : x(S, !1) }) } O(h, p) }; dt(f, h => { a.canScrollUp && h(d) }) } O(e, u), J() } var cv = rt("<!> <!>", 1); function uv(e, t) { Z(t, !0); let r = E(t, "value", 15), n = E(t, "onValueChange", 3, gt), o = E(t, "name", 3, ""), i = E(t, "disabled", 3, !1), s = E(t, "open", 15, !1), a = E(t, "onOpenChange", 3, gt), l = E(t, "onOpenChangeComplete", 3, gt), u = E(t, "loop", 3, !1), f = E(t, "scrollAlignment", 3, "nearest"), d = E(t, "required", 3, !1), h = E(t, "items", 19, () => []), p = E(t, "allowDeselect", 3, !1); function v() { r() === void 0 && r(t.type === "single" ? "" : []) } v(), ft.pre(() => r(), () => { v() }); let w = X(""); const _ = Vp.create({ type: t.type, value: T.with(() => r(), I => { r(I), n()(I) }), disabled: T.with(() => i()), required: T.with(() => d()), open: T.with(() => s(), I => { s(I), a()(I) }), loop: T.with(() => u()), scrollAlignment: T.with(() => f()), name: T.with(() => o()), isCombobox: !1, items: T.with(() => h()), allowDeselect: T.with(() => p()), inputValue: T.with(() => g(w), I => N(w, I, !0)), onOpenChangeComplete: T.with(() => l()) }); var S = cv(), x = F(S); Np(x, { children: (I, P) => { var C = H(), W = F(C); Y(W, () => t.children ?? et), O(I, C) }, $$slots: { default: !0 } }); var b = G(x, 2); { var m = I => { var P = H(), C = F(P); { var W = q => { var j = H(), K = F(j); bn(K, 16, () => _.opts.value.current, z => z, (z, R) => { Il(z, { get value() { return R }, get autocomplete() { return t.autocomplete } }) }), O(q, j) }; dt(C, q => { _.opts.value.current.length && q(W) }) } O(I, P) }, A = I => { Il(I, { get autocomplete() { return t.autocomplete }, get value() { return _.opts.value.current }, set value(P) { _.opts.value.current = P } }) }; dt(b, I => { Array.isArray(_.opts.value.current) ? I(m) : I(A, !1) }) } O(e, S), J() } var dv = rt("<button><!></button>"); function fv(e, t) { const r = Qr(); Z(t, !0); let n = E(t, "id", 19, () => en(r)), o = E(t, "ref", 15, null), i = E(t, "type", 3, "button"), s = ct(t, ["$$slots", "$$events", "$$legacy", "id", "ref", "child", "children", "type"]); const a = Hs.create({ id: T.with(() => n()), ref: T.with(() => o(), d => o(d)) }), l = M(() => Yt(s, a.props, { type: i() })); var u = H(), f = F(u); Ke(f, () => Hp, (d, h) => { h(d, { get id() { return n() }, get ref() { return a.opts.ref }, children: (p, v) => { var w = H(), _ = F(w); { var S = b => { var m = H(), A = F(m); Y(A, () => t.child, () => ({ props: g(l) })), O(b, m) }, x = b => { var m = dv(); mt(m, () => ({ ...g(l) })); var A = nt(m); Y(A, () => t.children ?? et), O(b, m) }; dt(_, b => { t.child ? b(S) : b(x, !1) }) } O(p, w) }, $$slots: { default: !0 } }) }), O(e, u), J() } const ka = "-", hv = e => { const t = pv(e), { conflictingClassGroups: r, conflictingClassGroupModifiers: n } = e; return { getClassGroupId: s => { const a = s.split(ka); return a[0] === "" && a.length !== 1 && a.shift(), Ou(a, t) || gv(s) }, getConflictingClassGroupIds: (s, a) => { const l = r[s] || []; return a && n[s] ? [...l, ...n[s]] : l } } }, Ou = (e, t) => { var s; if (e.length === 0) return t.classGroupId; const r = e[0], n = t.nextPart.get(r), o = n ? Ou(e.slice(1), n) : void 0; if (o) return o; if (t.validators.length === 0) return; const i = e.join(ka); return (s = t.validators.find(({ validator: a }) => a(i))) == null ? void 0 : s.classGroupId }, Rl = /^\[(.+)\]$/, gv = e => { if (Rl.test(e)) { const t = Rl.exec(e)[1], r = t == null ? void 0 : t.substring(0, t.indexOf(":")); if (r) return "arbitrary.." + r } }, pv = e => { const { theme: t, classGroups: r } = e, n = { nextPart: new Map, validators: [] }; for (const o in r) Js(r[o], n, o, t); return n }, Js = (e, t, r, n) => { e.forEach(o => { if (typeof o == "string") { const i = o === "" ? t : Ml(t, o); i.classGroupId = r; return } if (typeof o == "function") { if (vv(o)) { Js(o(n), t, r, n); return } t.validators.push({ validator: o, classGroupId: r }); return } Object.entries(o).forEach(([i, s]) => { Js(s, Ml(t, i), r, n) }) }) }, Ml = (e, t) => { let r = e; return t.split(ka).forEach(n => { r.nextPart.has(n) || r.nextPart.set(n, { nextPart: new Map, validators: [] }), r = r.nextPart.get(n) }), r }, vv = e => e.isThemeGetter, mv = e => { if (e < 1) return { get: () => { }, set: () => { } }; let t = 0, r = new Map, n = new Map; const o = (i, s) => { r.set(i, s), t++, t > e && (t = 0, n = r, r = new Map) }; return { get(i) { let s = r.get(i); if (s !== void 0) return s; if ((s = n.get(i)) !== void 0) return o(i, s), s }, set(i, s) { r.has(i) ? r.set(i, s) : o(i, s) } } }, Qs = "!", $s = ":", bv = $s.length, wv = e => { const { prefix: t, experimentalParseClassName: r } = e; let n = o => { const i = []; let s = 0, a = 0, l = 0, u; for (let v = 0; v < o.length; v++) { let w = o[v]; if (s === 0 && a === 0) { if (w === $s) { i.push(o.slice(l, v)), l = v + bv; continue } if (w === "/") { u = v; continue } } w === "[" ? s++ : w === "]" ? s-- : w === "(" ? a++ : w === ")" && a-- } const f = i.length === 0 ? o : o.substring(l), d = yv(f), h = d !== f, p = u && u > l ? u - l : void 0; return { modifiers: i, hasImportantModifier: h, baseClassName: d, maybePostfixModifierPosition: p } }; if (t) { const o = t + $s, i = n; n = s => s.startsWith(o) ? i(s.substring(o.length)) : { isExternal: !0, modifiers: [], hasImportantModifier: !1, baseClassName: s, maybePostfixModifierPosition: void 0 } } if (r) { const o = n; n = i => r({ className: i, parseClassName: o }) } return n }, yv = e => e.endsWith(Qs) ? e.substring(0, e.length - 1) : e.startsWith(Qs) ? e.substring(1) : e, _v = e => { const t = Object.fromEntries(e.orderSensitiveModifiers.map(n => [n, !0])); return n => { if (n.length <= 1) return n; const o = []; let i = []; return n.forEach(s => { s[0] === "[" || t[s] ? (o.push(...i.sort(), s), i = []) : i.push(s) }), o.push(...i.sort()), o } }, xv = e => ({ cache: mv(e.cacheSize), parseClassName: wv(e), sortModifiers: _v(e), ...hv(e) }), Sv = /\s+/, Av = (e, t) => { const { parseClassName: r, getClassGroupId: n, getConflictingClassGroupIds: o, sortModifiers: i } = t, s = [], a = e.trim().split(Sv); let l = ""; for (let u = a.length - 1; u >= 0; u -= 1) { const f = a[u], { isExternal: d, modifiers: h, hasImportantModifier: p, baseClassName: v, maybePostfixModifierPosition: w } = r(f); if (d) { l = f + (l.length > 0 ? " " + l : l); continue } let _ = !!w, S = n(_ ? v.substring(0, w) : v); if (!S) { if (!_) { l = f + (l.length > 0 ? " " + l : l); continue } if (S = n(v), !S) { l = f + (l.length > 0 ? " " + l : l); continue } _ = !1 } const x = i(h).join(":"), b = p ? x + Qs : x, m = b + S; if (s.includes(m)) continue; s.push(m); const A = o(S, _); for (let I = 0; I < A.length; ++I) { const P = A[I]; s.push(b + P) } l = f + (l.length > 0 ? " " + l : l) } return l }; function Pv() { let e = 0, t, r, n = ""; for (; e < arguments.length;)(t = arguments[e++]) && (r = Cu(t)) && (n && (n += " "), n += r); return n } const Cu = e => { if (typeof e == "string") return e; let t, r = ""; for (let n = 0; n < e.length; n++)e[n] && (t = Cu(e[n])) && (r && (r += " "), r += t); return r }; function Ev(e, ...t) { let r, n, o, i = s; function s(l) { const u = t.reduce((f, d) => d(f), e()); return r = xv(u), n = r.cache.get, o = r.cache.set, i = a, a(l) } function a(l) { const u = n(l); if (u) return u; const f = Av(l, r); return o(l, f), f } return function () { return i(Pv.apply(null, arguments)) } } const wt = e => { const t = r => r[e] || []; return t.isThemeGetter = !0, t }, Tu = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, ku = /^\((?:(\w[\w-]*):)?(.+)\)$/i, Ov = /^\d+\/\d+$/, Cv = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, Tv = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, kv = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, Nv = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, Iv = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, _r = e => Ov.test(e), Q = e => !!e && !Number.isNaN(Number(e)), Ne = e => !!e && Number.isInteger(Number(e)), vs = e => e.endsWith("%") && Q(e.slice(0, -1)), ge = e => Cv.test(e), Rv = () => !0, Mv = e => Tv.test(e) && !kv.test(e), Nu = () => !1, Dv = e => Nv.test(e), Fv = e => Iv.test(e), Lv = e => !L(e) && !B(e), Bv = e => on(e, Mu, Nu), L = e => Tu.test(e), $e = e => on(e, Du, Mv), ms = e => on(e, Uv, Q), Dl = e => on(e, Iu, Nu), zv = e => on(e, Ru, Fv), ii = e => on(e, Fu, Dv), B = e => ku.test(e), hn = e => sn(e, Du), Wv = e => sn(e, jv), Fl = e => sn(e, Iu), Vv = e => sn(e, Mu), Hv = e => sn(e, Ru), si = e => sn(e, Fu, !0), on = (e, t, r) => { const n = Tu.exec(e); return n ? n[1] ? t(n[1]) : r(n[2]) : !1 }, sn = (e, t, r = !1) => { const n = ku.exec(e); return n ? n[1] ? t(n[1]) : r : !1 }, Iu = e => e === "position" || e === "percentage", Ru = e => e === "image" || e === "url", Mu = e => e === "length" || e === "size" || e === "bg-size", Du = e => e === "length", Uv = e => e === "number", jv = e => e === "family-name", Fu = e => e === "shadow", Kv = () => { const e = wt("color"), t = wt("font"), r = wt("text"), n = wt("font-weight"), o = wt("tracking"), i = wt("leading"), s = wt("breakpoint"), a = wt("container"), l = wt("spacing"), u = wt("radius"), f = wt("shadow"), d = wt("inset-shadow"), h = wt("text-shadow"), p = wt("drop-shadow"), v = wt("blur"), w = wt("perspective"), _ = wt("aspect"), S = wt("ease"), x = wt("animate"), b = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], m = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"], A = () => [...m(), B, L], I = () => ["auto", "hidden", "clip", "visible", "scroll"], P = () => ["auto", "contain", "none"], C = () => [B, L, l], W = () => [_r, "full", "auto", ...C()], q = () => [Ne, "none", "subgrid", B, L], j = () => ["auto", { span: ["full", Ne, B, L] }, Ne, B, L], K = () => [Ne, "auto", B, L], z = () => ["auto", "min", "max", "fr", B, L], R = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], U = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], $ = () => ["auto", ...C()], tt = () => [_r, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...C()], D = () => [e, B, L], Et = () => [...m(), Fl, Dl, { position: [B, L] }], vr = () => ["no-repeat", { repeat: ["", "x", "y", "space", "round"] }], is = () => ["auto", "cover", "contain", Vv, Bv, { size: [B, L] }], mr = () => [vs, hn, $e], _t = () => ["", "none", "full", u, B, L], Ot = () => ["", Q, hn, $e], br = () => ["solid", "dashed", "dotted", "double"], ke = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], vt = () => [Q, vs, Fl, Dl], de = () => ["", "none", v, B, L], Ze = () => ["none", Q, B, L], fe = () => ["none", Q, B, L], ut = () => [Q, B, L], he = () => [_r, "full", ...C()]; return { cacheSize: 500, theme: { animate: ["spin", "ping", "pulse", "bounce"], aspect: ["video"], blur: [ge], breakpoint: [ge], color: [Rv], container: [ge], "drop-shadow": [ge], ease: ["in", "out", "in-out"], font: [Lv], "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"], "inset-shadow": [ge], leading: ["none", "tight", "snug", "normal", "relaxed", "loose"], perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"], radius: [ge], shadow: [ge], spacing: ["px", Q], text: [ge], "text-shadow": [ge], tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"] }, classGroups: { aspect: [{ aspect: ["auto", "square", _r, L, B, _] }], container: ["container"], columns: [{ columns: [Q, L, B, a] }], "break-after": [{ "break-after": b() }], "break-before": [{ "break-before": b() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], sr: ["sr-only", "not-sr-only"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: A() }], overflow: [{ overflow: I() }], "overflow-x": [{ "overflow-x": I() }], "overflow-y": [{ "overflow-y": I() }], overscroll: [{ overscroll: P() }], "overscroll-x": [{ "overscroll-x": P() }], "overscroll-y": [{ "overscroll-y": P() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: W() }], "inset-x": [{ "inset-x": W() }], "inset-y": [{ "inset-y": W() }], start: [{ start: W() }], end: [{ end: W() }], top: [{ top: W() }], right: [{ right: W() }], bottom: [{ bottom: W() }], left: [{ left: W() }], visibility: ["visible", "invisible", "collapse"], z: [{ z: [Ne, "auto", B, L] }], basis: [{ basis: [_r, "full", "auto", a, ...C()] }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["nowrap", "wrap", "wrap-reverse"] }], flex: [{ flex: [Q, _r, "auto", "initial", "none", L] }], grow: [{ grow: ["", Q, B, L] }], shrink: [{ shrink: ["", Q, B, L] }], order: [{ order: [Ne, "first", "last", "none", B, L] }], "grid-cols": [{ "grid-cols": q() }], "col-start-end": [{ col: j() }], "col-start": [{ "col-start": K() }], "col-end": [{ "col-end": K() }], "grid-rows": [{ "grid-rows": q() }], "row-start-end": [{ row: j() }], "row-start": [{ "row-start": K() }], "row-end": [{ "row-end": K() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": z() }], "auto-rows": [{ "auto-rows": z() }], gap: [{ gap: C() }], "gap-x": [{ "gap-x": C() }], "gap-y": [{ "gap-y": C() }], "justify-content": [{ justify: [...R(), "normal"] }], "justify-items": [{ "justify-items": [...U(), "normal"] }], "justify-self": [{ "justify-self": ["auto", ...U()] }], "align-content": [{ content: ["normal", ...R()] }], "align-items": [{ items: [...U(), { baseline: ["", "last"] }] }], "align-self": [{ self: ["auto", ...U(), { baseline: ["", "last"] }] }], "place-content": [{ "place-content": R() }], "place-items": [{ "place-items": [...U(), "baseline"] }], "place-self": [{ "place-self": ["auto", ...U()] }], p: [{ p: C() }], px: [{ px: C() }], py: [{ py: C() }], ps: [{ ps: C() }], pe: [{ pe: C() }], pt: [{ pt: C() }], pr: [{ pr: C() }], pb: [{ pb: C() }], pl: [{ pl: C() }], m: [{ m: $() }], mx: [{ mx: $() }], my: [{ my: $() }], ms: [{ ms: $() }], me: [{ me: $() }], mt: [{ mt: $() }], mr: [{ mr: $() }], mb: [{ mb: $() }], ml: [{ ml: $() }], "space-x": [{ "space-x": C() }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": C() }], "space-y-reverse": ["space-y-reverse"], size: [{ size: tt() }], w: [{ w: [a, "screen", ...tt()] }], "min-w": [{ "min-w": [a, "screen", "none", ...tt()] }], "max-w": [{ "max-w": [a, "screen", "none", "prose", { screen: [s] }, ...tt()] }], h: [{ h: ["screen", "lh", ...tt()] }], "min-h": [{ "min-h": ["screen", "lh", "none", ...tt()] }], "max-h": [{ "max-h": ["screen", "lh", ...tt()] }], "font-size": [{ text: ["base", r, hn, $e] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: [n, B, ms] }], "font-stretch": [{ "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", vs, L] }], "font-family": [{ font: [Wv, L, t] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: [o, B, L] }], "line-clamp": [{ "line-clamp": [Q, "none", B, ms] }], leading: [{ leading: [i, ...C()] }], "list-image": [{ "list-image": ["none", B, L] }], "list-style-position": [{ list: ["inside", "outside"] }], "list-style-type": [{ list: ["disc", "decimal", "none", B, L] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "placeholder-color": [{ placeholder: D() }], "text-color": [{ text: D() }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...br(), "wavy"] }], "text-decoration-thickness": [{ decoration: [Q, "from-font", "auto", B, $e] }], "text-decoration-color": [{ decoration: D() }], "underline-offset": [{ "underline-offset": [Q, "auto", B, L] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: C() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", B, L] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], wrap: [{ wrap: ["break-word", "anywhere", "normal"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", B, L] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: Et() }], "bg-repeat": [{ bg: vr() }], "bg-size": [{ bg: is() }], "bg-image": [{ bg: ["none", { linear: [{ to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, Ne, B, L], radial: ["", B, L], conic: [Ne, B, L] }, Hv, zv] }], "bg-color": [{ bg: D() }], "gradient-from-pos": [{ from: mr() }], "gradient-via-pos": [{ via: mr() }], "gradient-to-pos": [{ to: mr() }], "gradient-from": [{ from: D() }], "gradient-via": [{ via: D() }], "gradient-to": [{ to: D() }], rounded: [{ rounded: _t() }], "rounded-s": [{ "rounded-s": _t() }], "rounded-e": [{ "rounded-e": _t() }], "rounded-t": [{ "rounded-t": _t() }], "rounded-r": [{ "rounded-r": _t() }], "rounded-b": [{ "rounded-b": _t() }], "rounded-l": [{ "rounded-l": _t() }], "rounded-ss": [{ "rounded-ss": _t() }], "rounded-se": [{ "rounded-se": _t() }], "rounded-ee": [{ "rounded-ee": _t() }], "rounded-es": [{ "rounded-es": _t() }], "rounded-tl": [{ "rounded-tl": _t() }], "rounded-tr": [{ "rounded-tr": _t() }], "rounded-br": [{ "rounded-br": _t() }], "rounded-bl": [{ "rounded-bl": _t() }], "border-w": [{ border: Ot() }], "border-w-x": [{ "border-x": Ot() }], "border-w-y": [{ "border-y": Ot() }], "border-w-s": [{ "border-s": Ot() }], "border-w-e": [{ "border-e": Ot() }], "border-w-t": [{ "border-t": Ot() }], "border-w-r": [{ "border-r": Ot() }], "border-w-b": [{ "border-b": Ot() }], "border-w-l": [{ "border-l": Ot() }], "divide-x": [{ "divide-x": Ot() }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": Ot() }], "divide-y-reverse": ["divide-y-reverse"], "border-style": [{ border: [...br(), "hidden", "none"] }], "divide-style": [{ divide: [...br(), "hidden", "none"] }], "border-color": [{ border: D() }], "border-color-x": [{ "border-x": D() }], "border-color-y": [{ "border-y": D() }], "border-color-s": [{ "border-s": D() }], "border-color-e": [{ "border-e": D() }], "border-color-t": [{ "border-t": D() }], "border-color-r": [{ "border-r": D() }], "border-color-b": [{ "border-b": D() }], "border-color-l": [{ "border-l": D() }], "divide-color": [{ divide: D() }], "outline-style": [{ outline: [...br(), "none", "hidden"] }], "outline-offset": [{ "outline-offset": [Q, B, L] }], "outline-w": [{ outline: ["", Q, hn, $e] }], "outline-color": [{ outline: D() }], shadow: [{ shadow: ["", "none", f, si, ii] }], "shadow-color": [{ shadow: D() }], "inset-shadow": [{ "inset-shadow": ["none", d, si, ii] }], "inset-shadow-color": [{ "inset-shadow": D() }], "ring-w": [{ ring: Ot() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: D() }], "ring-offset-w": [{ "ring-offset": [Q, $e] }], "ring-offset-color": [{ "ring-offset": D() }], "inset-ring-w": [{ "inset-ring": Ot() }], "inset-ring-color": [{ "inset-ring": D() }], "text-shadow": [{ "text-shadow": ["none", h, si, ii] }], "text-shadow-color": [{ "text-shadow": D() }], opacity: [{ opacity: [Q, B, L] }], "mix-blend": [{ "mix-blend": [...ke(), "plus-darker", "plus-lighter"] }], "bg-blend": [{ "bg-blend": ke() }], "mask-clip": [{ "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"] }, "mask-no-clip"], "mask-composite": [{ mask: ["add", "subtract", "intersect", "exclude"] }], "mask-image-linear-pos": [{ "mask-linear": [Q] }], "mask-image-linear-from-pos": [{ "mask-linear-from": vt() }], "mask-image-linear-to-pos": [{ "mask-linear-to": vt() }], "mask-image-linear-from-color": [{ "mask-linear-from": D() }], "mask-image-linear-to-color": [{ "mask-linear-to": D() }], "mask-image-t-from-pos": [{ "mask-t-from": vt() }], "mask-image-t-to-pos": [{ "mask-t-to": vt() }], "mask-image-t-from-color": [{ "mask-t-from": D() }], "mask-image-t-to-color": [{ "mask-t-to": D() }], "mask-image-r-from-pos": [{ "mask-r-from": vt() }], "mask-image-r-to-pos": [{ "mask-r-to": vt() }], "mask-image-r-from-color": [{ "mask-r-from": D() }], "mask-image-r-to-color": [{ "mask-r-to": D() }], "mask-image-b-from-pos": [{ "mask-b-from": vt() }], "mask-image-b-to-pos": [{ "mask-b-to": vt() }], "mask-image-b-from-color": [{ "mask-b-from": D() }], "mask-image-b-to-color": [{ "mask-b-to": D() }], "mask-image-l-from-pos": [{ "mask-l-from": vt() }], "mask-image-l-to-pos": [{ "mask-l-to": vt() }], "mask-image-l-from-color": [{ "mask-l-from": D() }], "mask-image-l-to-color": [{ "mask-l-to": D() }], "mask-image-x-from-pos": [{ "mask-x-from": vt() }], "mask-image-x-to-pos": [{ "mask-x-to": vt() }], "mask-image-x-from-color": [{ "mask-x-from": D() }], "mask-image-x-to-color": [{ "mask-x-to": D() }], "mask-image-y-from-pos": [{ "mask-y-from": vt() }], "mask-image-y-to-pos": [{ "mask-y-to": vt() }], "mask-image-y-from-color": [{ "mask-y-from": D() }], "mask-image-y-to-color": [{ "mask-y-to": D() }], "mask-image-radial": [{ "mask-radial": [B, L] }], "mask-image-radial-from-pos": [{ "mask-radial-from": vt() }], "mask-image-radial-to-pos": [{ "mask-radial-to": vt() }], "mask-image-radial-from-color": [{ "mask-radial-from": D() }], "mask-image-radial-to-color": [{ "mask-radial-to": D() }], "mask-image-radial-shape": [{ "mask-radial": ["circle", "ellipse"] }], "mask-image-radial-size": [{ "mask-radial": [{ closest: ["side", "corner"], farthest: ["side", "corner"] }] }], "mask-image-radial-pos": [{ "mask-radial-at": m() }], "mask-image-conic-pos": [{ "mask-conic": [Q] }], "mask-image-conic-from-pos": [{ "mask-conic-from": vt() }], "mask-image-conic-to-pos": [{ "mask-conic-to": vt() }], "mask-image-conic-from-color": [{ "mask-conic-from": D() }], "mask-image-conic-to-color": [{ "mask-conic-to": D() }], "mask-mode": [{ mask: ["alpha", "luminance", "match"] }], "mask-origin": [{ "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"] }], "mask-position": [{ mask: Et() }], "mask-repeat": [{ mask: vr() }], "mask-size": [{ mask: is() }], "mask-type": [{ "mask-type": ["alpha", "luminance"] }], "mask-image": [{ mask: ["none", B, L] }], filter: [{ filter: ["", "none", B, L] }], blur: [{ blur: de() }], brightness: [{ brightness: [Q, B, L] }], contrast: [{ contrast: [Q, B, L] }], "drop-shadow": [{ "drop-shadow": ["", "none", p, si, ii] }], "drop-shadow-color": [{ "drop-shadow": D() }], grayscale: [{ grayscale: ["", Q, B, L] }], "hue-rotate": [{ "hue-rotate": [Q, B, L] }], invert: [{ invert: ["", Q, B, L] }], saturate: [{ saturate: [Q, B, L] }], sepia: [{ sepia: ["", Q, B, L] }], "backdrop-filter": [{ "backdrop-filter": ["", "none", B, L] }], "backdrop-blur": [{ "backdrop-blur": de() }], "backdrop-brightness": [{ "backdrop-brightness": [Q, B, L] }], "backdrop-contrast": [{ "backdrop-contrast": [Q, B, L] }], "backdrop-grayscale": [{ "backdrop-grayscale": ["", Q, B, L] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [Q, B, L] }], "backdrop-invert": [{ "backdrop-invert": ["", Q, B, L] }], "backdrop-opacity": [{ "backdrop-opacity": [Q, B, L] }], "backdrop-saturate": [{ "backdrop-saturate": [Q, B, L] }], "backdrop-sepia": [{ "backdrop-sepia": ["", Q, B, L] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": C() }], "border-spacing-x": [{ "border-spacing-x": C() }], "border-spacing-y": [{ "border-spacing-y": C() }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", B, L] }], "transition-behavior": [{ transition: ["normal", "discrete"] }], duration: [{ duration: [Q, "initial", B, L] }], ease: [{ ease: ["linear", "initial", S, B, L] }], delay: [{ delay: [Q, B, L] }], animate: [{ animate: ["none", x, B, L] }], backface: [{ backface: ["hidden", "visible"] }], perspective: [{ perspective: [w, B, L] }], "perspective-origin": [{ "perspective-origin": A() }], rotate: [{ rotate: Ze() }], "rotate-x": [{ "rotate-x": Ze() }], "rotate-y": [{ "rotate-y": Ze() }], "rotate-z": [{ "rotate-z": Ze() }], scale: [{ scale: fe() }], "scale-x": [{ "scale-x": fe() }], "scale-y": [{ "scale-y": fe() }], "scale-z": [{ "scale-z": fe() }], "scale-3d": ["scale-3d"], skew: [{ skew: ut() }], "skew-x": [{ "skew-x": ut() }], "skew-y": [{ "skew-y": ut() }], transform: [{ transform: [B, L, "", "none", "gpu", "cpu"] }], "transform-origin": [{ origin: A() }], "transform-style": [{ transform: ["3d", "flat"] }], translate: [{ translate: he() }], "translate-x": [{ "translate-x": he() }], "translate-y": [{ "translate-y": he() }], "translate-z": [{ "translate-z": he() }], "translate-none": ["translate-none"], accent: [{ accent: D() }], appearance: [{ appearance: ["none", "auto"] }], "caret-color": [{ caret: D() }], "color-scheme": [{ scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", B, L] }], "field-sizing": [{ "field-sizing": ["fixed", "content"] }], "pointer-events": [{ "pointer-events": ["auto", "none"] }], resize: [{ resize: ["none", "", "y", "x"] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": C() }], "scroll-mx": [{ "scroll-mx": C() }], "scroll-my": [{ "scroll-my": C() }], "scroll-ms": [{ "scroll-ms": C() }], "scroll-me": [{ "scroll-me": C() }], "scroll-mt": [{ "scroll-mt": C() }], "scroll-mr": [{ "scroll-mr": C() }], "scroll-mb": [{ "scroll-mb": C() }], "scroll-ml": [{ "scroll-ml": C() }], "scroll-p": [{ "scroll-p": C() }], "scroll-px": [{ "scroll-px": C() }], "scroll-py": [{ "scroll-py": C() }], "scroll-ps": [{ "scroll-ps": C() }], "scroll-pe": [{ "scroll-pe": C() }], "scroll-pt": [{ "scroll-pt": C() }], "scroll-pr": [{ "scroll-pr": C() }], "scroll-pb": [{ "scroll-pb": C() }], "scroll-pl": [{ "scroll-pl": C() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", B, L] }], fill: [{ fill: ["none", ...D()] }], "stroke-w": [{ stroke: [Q, hn, $e, ms] }], stroke: [{ stroke: ["none", ...D()] }], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], translate: ["translate-x", "translate-y", "translate-none"], "translate-none": ["translate", "translate-x", "translate-y", "translate-z"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] }, orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"] } }, Gv = Ev(Kv); function Wt(...e) { return Gv(wn(e)) }/**
 * @license @lucide/svelte v0.515.0 - ISC
 *
 * ISC License
 * 
 * Copyright (c) for portions of Lucide are held by Cole Bemis 2013-2022 as part of Feather (MIT). All other copyright (c) for Lucide are held by Lucide Contributors 2022.
 * 
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 */const qv = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": 2, "stroke-linecap": "round", "stroke-linejoin": "round" }; var Yv = cf("<svg><!><!></svg>"); function Na(e, t) { Z(t, !0); const r = E(t, "color", 3, "currentColor"), n = E(t, "size", 3, 24), o = E(t, "strokeWidth", 3, 2), i = E(t, "absoluteStrokeWidth", 3, !1), s = E(t, "iconNode", 19, () => []), a = ct(t, ["$$slots", "$$events", "$$legacy", "name", "color", "size", "strokeWidth", "absoluteStrokeWidth", "iconNode", "children"]); var l = Yv(); mt(l, d => ({ ...qv, ...a, width: n(), height: n(), stroke: r(), "stroke-width": d, class: ["lucide-icon lucide", t.name && `lucide-${t.name}`, t.class] }), [() => i() ? Number(o()) * 24 / Number(n()) : o()]); var u = nt(l); bn(u, 17, s, ai, (d, h) => { var p = M(() => Xu(g(h), 2)); let v = () => g(p)[0], w = () => g(p)[1]; var _ = H(), S = F(_); mf(S, v, !0, (x, b) => { mt(x, () => ({ ...w() })) }), O(d, _) }); var f = G(u); Y(f, () => t.children ?? et), O(e, l), J() } function Xv(e, t) { Z(t, !0); let r = ct(t, ["$$slots", "$$events", "$$legacy"]); const n = [["path", { d: "M20 6 9 17l-5-5" }]]; Na(e, Mt({ name: "check" }, () => r, { get iconNode() { return n }, children: (o, i) => { var s = H(), a = F(s); Y(a, () => t.children ?? et), O(o, s) }, $$slots: { default: !0 } })), J() } var Zv = rt('<span class="absolute right-2 flex size-3.5 items-center justify-center"><!></span> <!>', 1); function Ll(e, t) { Z(t, !0); let r = E(t, "ref", 15, null), n = ct(t, ["$$slots", "$$events", "$$legacy", "ref", "class", "value", "label", "children"]); var o = H(), i = F(o); const s = M(() => Wt("data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2 relative flex w-full cursor-default select-none items-center gap-2 rounded-sm py-1.5 pl-2 pr-8 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", t.class)); { const a = (l, u) => { let f = () => u == null ? void 0 : u().selected, d = () => u == null ? void 0 : u().highlighted; var h = Zv(), p = F(h), v = nt(p); { var w = b => { Xv(b, { class: "size-4" }) }; dt(v, b => { f() && b(w) }) } var _ = G(p, 2); { var S = b => { var m = H(), A = F(m); Y(A, () => t.children, () => ({ selected: f(), highlighted: d() })), O(b, m) }, x = b => { var m = pt(); Nt(() => At(m, t.label || t.value)), O(b, m) }; dt(_, b => { t.children ? b(S) : b(x, !1) }) } O(l, h) }; Ke(i, () => tv, (l, u) => { u(l, Mt({ get value() { return t.value }, "data-slot": "select-item", get class() { return g(s) } }, () => n, { get ref() { return r() }, set ref(f) { r(f) }, children: a, $$slots: { default: !0 } })) }) } O(e, o), J() } function Jv(e, t) { Z(t, !0); let r = ct(t, ["$$slots", "$$events", "$$legacy"]); const n = [["path", { d: "m18 15-6-6-6 6" }]]; Na(e, Mt({ name: "chevron-up" }, () => r, { get iconNode() { return n }, children: (o, i) => { var s = H(), a = F(s); Y(a, () => t.children ?? et), O(o, s) }, $$slots: { default: !0 } })), J() } function Qv(e, t) { Z(t, !0); let r = E(t, "ref", 15, null), n = ct(t, ["$$slots", "$$events", "$$legacy", "ref", "class"]); var o = H(), i = F(o); const s = M(() => Wt("flex cursor-default items-center justify-center py-1", t.class)); Ke(i, () => lv, (a, l) => { l(a, Mt({ "data-slot": "select-scroll-up-button", get class() { return g(s) } }, () => n, { get ref() { return r() }, set ref(u) { r(u) }, children: (u, f) => { Jv(u, { class: "size-4" }) }, $$slots: { default: !0 } })) }), O(e, o), J() } function Lu(e, t) { Z(t, !0); let r = ct(t, ["$$slots", "$$events", "$$legacy"]); const n = [["path", { d: "m6 9 6 6 6-6" }]]; Na(e, Mt({ name: "chevron-down" }, () => r, { get iconNode() { return n }, children: (o, i) => { var s = H(), a = F(s); Y(a, () => t.children ?? et), O(o, s) }, $$slots: { default: !0 } })), J() } function $v(e, t) { Z(t, !0); let r = E(t, "ref", 15, null), n = ct(t, ["$$slots", "$$events", "$$legacy", "ref", "class"]); var o = H(), i = F(o); const s = M(() => Wt("flex cursor-default items-center justify-center py-1", t.class)); Ke(i, () => iv, (a, l) => { l(a, Mt({ "data-slot": "select-scroll-down-button", get class() { return g(s) } }, () => n, { get ref() { return r() }, set ref(u) { r(u) }, children: (u, f) => { Lu(u, { class: "size-4" }) }, $$slots: { default: !0 } })) }), O(e, o), J() } var tm = rt("<!> <!> <!>", 1); function Bl(e, t) { Z(t, !0); let r = E(t, "ref", 15, null), n = E(t, "sideOffset", 3, 4), o = ct(t, ["$$slots", "$$events", "$$legacy", "ref", "class", "sideOffset", "portalProps", "children"]); var i = H(), s = F(i); Ke(s, () => Xh, (a, l) => { l(a, Mt(() => t.portalProps, { children: (u, f) => { var d = H(), h = F(d); const p = M(() => Wt("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 max-h-(--bits-select-content-available-height) origin-(--bits-select-content-transform-origin) relative z-50 min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border shadow-md data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", t.class)); Ke(h, () => Jp, (v, w) => { w(v, Mt({ get sideOffset() { return n() }, "data-slot": "select-content", get class() { return g(p) } }, () => o, { get ref() { return r() }, set ref(_) { r(_) }, children: (_, S) => { var x = tm(), b = F(x); Qv(b, {}); var m = G(b, 2); const A = M(() => Wt("h-(--bits-select-anchor-height) min-w-(--bits-select-anchor-width) w-full scroll-my-1 p-1")); Ke(m, () => rv, (P, C) => { C(P, { get class() { return g(A) }, children: (W, q) => { var j = H(), K = F(j); Y(K, () => t.children ?? et), O(W, j) }, $$slots: { default: !0 } }) }); var I = G(m, 2); $v(I, {}), O(_, x) }, $$slots: { default: !0 } })) }), O(u, d) }, $$slots: { default: !0 } })) }), O(e, i), J() } var em = rt("<!> <!>", 1); function zl(e, t) { Z(t, !0); let r = E(t, "ref", 15, null), n = E(t, "size", 3, "default"), o = ct(t, ["$$slots", "$$events", "$$legacy", "ref", "class", "children", "size"]); var i = H(), s = F(i); const a = M(() => Wt("border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 shadow-xs flex w-fit select-none items-center justify-between gap-2 whitespace-nowrap rounded-md border bg-transparent px-3 py-2 text-sm outline-none transition-[color,box-shadow] focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", t.class)); Ke(s, () => fv, (l, u) => { u(l, Mt({ "data-slot": "select-trigger", get "data-size"() { return n() }, get class() { return g(a) } }, () => o, { get ref() { return r() }, set ref(f) { r(f) }, children: (f, d) => { var h = em(), p = F(h); Y(p, () => t.children ?? et); var v = G(p, 2); Lu(v, { class: "size-4 opacity-50" }), O(f, h) }, $$slots: { default: !0 } })) }), O(e, i), J() } const Wl = uv; var rm = rt('<div data-slot="table-container" class="relative w-full overflow-x-auto"><table><!></table></div>'); function nm(e, t) { Z(t, !0); let r = E(t, "ref", 15, null), n = ct(t, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]); var o = rm(), i = nt(o); mt(i, a => ({ "data-slot": "table", class: a, ...n }), [() => Wt("w-full caption-bottom text-sm", t.class)]); var s = nt(i); Y(s, () => t.children ?? et), pr(i, a => r(a), () => r()), O(e, o), J() } var om = rt("<tbody><!></tbody>"); function im(e, t) { Z(t, !0); let r = E(t, "ref", 15, null), n = ct(t, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]); var o = om(); mt(o, s => ({ "data-slot": "table-body", class: s, ...n }), [() => Wt("[&_tr:last-child]:border-0", t.class)]); var i = nt(o); Y(i, () => t.children ?? et), pr(o, s => r(s), () => r()), O(e, o), J() } var sm = rt("<caption><!></caption>"); function am(e, t) { Z(t, !0); let r = E(t, "ref", 15, null), n = ct(t, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]); var o = sm(); mt(o, s => ({ "data-slot": "table-caption", class: s, ...n }), [() => Wt("text-muted-foreground mt-4 text-sm", t.class)]); var i = nt(o); Y(i, () => t.children ?? et), pr(o, s => r(s), () => r()), O(e, o), J() } var lm = rt("<td><!></td>"); function Ie(e, t) { Z(t, !0); let r = E(t, "ref", 15, null), n = ct(t, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]); var o = lm(); mt(o, s => ({ "data-slot": "table-cell", class: s, ...n }), [() => Wt("whitespace-nowrap p-2 align-middle [&:has([role=checkbox])]:pr-0", t.class)]); var i = nt(o); Y(i, () => t.children ?? et), pr(o, s => r(s), () => r()), O(e, o), J() } var cm = rt("<th><!></th>"); function Re(e, t) { Z(t, !0); let r = E(t, "ref", 15, null), n = ct(t, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]); var o = cm(); mt(o, s => ({ "data-slot": "table-head", class: s, ...n }), [() => Wt("text-foreground h-10 whitespace-nowrap px-2 text-left align-middle font-medium [&:has([role=checkbox])]:pr-0", t.class)]); var i = nt(o); Y(i, () => t.children ?? et), pr(o, s => r(s), () => r()), O(e, o), J() } var um = rt("<thead><!></thead>"); function dm(e, t) { Z(t, !0); let r = E(t, "ref", 15, null), n = ct(t, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]); var o = um(); mt(o, s => ({ "data-slot": "table-header", class: s, ...n }), [() => Wt("[&_tr]:border-b", t.class)]); var i = nt(o); Y(i, () => t.children ?? et), pr(o, s => r(s), () => r()), O(e, o), J() } var fm = rt("<tr><!></tr>"); function Vl(e, t) { Z(t, !0); let r = E(t, "ref", 15, null), n = ct(t, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]); var o = fm(); mt(o, s => ({ "data-slot": "table-row", class: s, ...n }), [() => Wt("hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors", t.class)]); var i = nt(o); Y(i, () => t.children ?? et), pr(o, s => r(s), () => r()), O(e, o), J() } var hm = rt("<!> <!>", 1), gm = rt("<!> <!>", 1), pm = rt("<!> <!> <!> <!> <!> <!> <!> <!>", 1), vm = rt("<!> <!> <!> <!> <!> <!> <!> <!>", 1), mm = rt("<!> <!> <!>", 1), bm = rt('<div class="mb-4 flex gap-6"><div>Total: <b> </b></div> <div>Winrate: <b> </b></div> <div>Lossrate: <b> </b></div> <div>Balance: <b> </b></div></div> <!>', 1), wm = rt("<div>Cargando...</div>"), ym = rt("<div>No hay datos.</div>"), _m = rt('<div class="flex gap-4 mb-4 items-end"><div><label class="block mb-1">Mes</label> <!></div> <div><label class="block mb-1">Año</label> <!></div> <button type="button" class="px-4 py-2 border rounded bg-transparent text-inherit border-gray-400 hover:bg-gray-800 disabled:opacity-50"> </button></div> <!>', 1); function xm(e, t) { Z(t, !1); let r = Ar(String(new Date().getFullYear())), n = Ar(String(new Date().getMonth() + 1)), o = Ar(null), i = Ar(!1); const s = ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"], a = Array.from({ length: 5 }, (m, A) => String(Number(g(r)) - A)); async function l() { N(i, !0); const m = await fetch(`/api/trades?mes=${g(n)}&anio=${g(r)}`); N(o, await m.json()), N(i, !1) } Nc(l), Cf(); var u = _m(), f = F(u), d = nt(f), h = G(nt(d), 2); Wl(h, { type: "single", get value() { return g(n) }, set value(m) { N(n, m) }, children: (m, A) => { var I = hm(), P = F(I); zl(P, { children: (W, q) => { var j = pt(); Nt(K => At(j, K), [() => (g(n), at(() => s[Number(g(n)) - 1]))], re), O(W, j) }, $$slots: { default: !0 } }); var C = G(P, 2); Bl(C, { children: (W, q) => { var j = H(), K = F(j); bn(K, 1, () => s, ai, (z, R, U) => { const $ = re(() => at(() => String(U + 1))); Ll(z, { get value() { return g($) }, children: (tt, D) => { var Et = pt(); Nt(() => At(Et, g(R))), O(tt, Et) }, $$slots: { default: !0 } }) }), O(W, j) }, $$slots: { default: !0 } }), O(m, I) }, $$slots: { default: !0 }, $$legacy: !0 }); var p = G(d, 2), v = G(nt(p), 2); Wl(v, { type: "single", get value() { return g(r) }, set value(m) { N(r, m) }, children: (m, A) => { var I = gm(), P = F(I); zl(P, { children: (W, q) => { var j = pt(); Nt(() => At(j, g(r))), O(W, j) }, $$slots: { default: !0 } }); var C = G(P, 2); Bl(C, { children: (W, q) => { var j = H(), K = F(j); bn(K, 1, () => a, ai, (z, R) => { Ll(z, { get value() { return g(R) }, children: (U, $) => { var tt = pt(); Nt(() => At(tt, g(R))), O(U, tt) }, $$slots: { default: !0 } }) }), O(W, j) }, $$slots: { default: !0 } }), O(m, I) }, $$slots: { default: !0 }, $$legacy: !0 }); var w = G(p, 2), _ = nt(w), S = G(f, 2); { var x = m => { var A = bm(), I = F(A), P = nt(I), C = G(nt(P)), W = nt(C), q = G(P, 2), j = G(nt(q)), K = nt(j), z = G(q, 2), R = G(nt(z)), U = nt(R), $ = G(z, 2), tt = G(nt($)), D = nt(tt), Et = G(I, 2); nm(Et, { class: "w-full border rounded-lg overflow-x-auto text-sm", children: (vr, is) => { var mr = mm(), _t = F(mr); am(_t, { class: "mb-2 text-muted-foreground", children: (ke, vt) => { var de = pt("Lista de trades recientes"); O(ke, de) }, $$slots: { default: !0 } }); var Ot = G(_t, 2); dm(Ot, { children: (ke, vt) => { Vl(ke, { class: "bg-muted text-muted-foreground", children: (de, Ze) => { var fe = pm(), ut = F(fe); Re(ut, { class: "p-2 font-semibold border-b", children: (xt, $t) => { var St = pt("Fecha"); O(xt, St) }, $$slots: { default: !0 } }); var he = G(ut, 2); Re(he, { class: "p-2 font-semibold border-b", children: (xt, $t) => { var St = pt("Activo"); O(xt, St) }, $$slots: { default: !0 } }); var ti = G(he, 2); Re(ti, { class: "p-2 font-semibold border-b", children: (xt, $t) => { var St = pt("Tipo"); O(xt, St) }, $$slots: { default: !0 } }); var ss = G(ti, 2); Re(ss, { class: "p-2 font-semibold border-b", children: (xt, $t) => { var St = pt("Entrada"); O(xt, St) }, $$slots: { default: !0 } }); var an = G(ss, 2); Re(an, { class: "p-2 font-semibold border-b", children: (xt, $t) => { var St = pt("TP"); O(xt, St) }, $$slots: { default: !0 } }); var ln = G(an, 2); Re(ln, { class: "p-2 font-semibold border-b", children: (xt, $t) => { var St = pt("SL"); O(xt, St) }, $$slots: { default: !0 } }); var cn = G(ln, 2); Re(cn, { class: "p-2 font-semibold border-b", children: (xt, $t) => { var St = pt("Ganancia Neta"); O(xt, St) }, $$slots: { default: !0 } }); var ei = G(cn, 2); Re(ei, { class: "p-2 font-semibold border-b", children: (xt, $t) => { var St = pt("Ganado"); O(xt, St) }, $$slots: { default: !0 } }), O(de, fe) }, $$slots: { default: !0 } }) }, $$slots: { default: !0 } }); var br = G(Ot, 2); im(br, { children: (ke, vt) => { var de = H(), Ze = F(de); bn(Ze, 1, () => (g(o), at(() => g(o).trades)), ai, (fe, ut) => { const he = re(() => (g(ut), at(() => g(ut).ganado ? "bg-green-100/60 dark:bg-green-900/40" : "bg-red-100/60 dark:bg-red-900/40"))); Vl(fe, { get class() { return g(he) }, children: (ti, ss) => { var an = vm(), ln = F(an); Ie(ln, { class: "p-2 border-b", children: (kt, Je) => { var ht = pt(); Nt(zu => At(ht, zu), [() => (g(ut), at(() => g(ut).fecha.slice(0, 10)))], re), O(kt, ht) }, $$slots: { default: !0 } }); var cn = G(ln, 2); Ie(cn, { class: "p-2 border-b", children: (kt, Je) => { var ht = pt(); Nt(() => At(ht, (g(ut), at(() => g(ut).activo)))), O(kt, ht) }, $$slots: { default: !0 } }); var ei = G(cn, 2); Ie(ei, { class: "p-2 border-b", children: (kt, Je) => { var ht = pt(); Nt(() => At(ht, (g(ut), at(() => g(ut).tipo)))), O(kt, ht) }, $$slots: { default: !0 } }); var xt = G(ei, 2); Ie(xt, { class: "p-2 border-b", children: (kt, Je) => { var ht = pt(); Nt(() => At(ht, (g(ut), at(() => g(ut).entrada)))), O(kt, ht) }, $$slots: { default: !0 } }); var $t = G(xt, 2); Ie($t, { class: "p-2 border-b", children: (kt, Je) => { var ht = pt(); Nt(() => At(ht, (g(ut), at(() => g(ut).tp)))), O(kt, ht) }, $$slots: { default: !0 } }); var St = G($t, 2); Ie(St, { class: "p-2 border-b", children: (kt, Je) => { var ht = pt(); Nt(() => At(ht, (g(ut), at(() => g(ut).sl)))), O(kt, ht) }, $$slots: { default: !0 } }); var ja = G(St, 2); Ie(ja, { class: "p-2 border-b", children: (kt, Je) => { var ht = pt(); Nt(() => At(ht, (g(ut), at(() => g(ut).ganancia_neta)))), O(kt, ht) }, $$slots: { default: !0 } }); var Bu = G(ja, 2); Ie(Bu, { class: "p-2 border-b text-center text-lg", children: (kt, Je) => { var ht = pt(); Nt(() => At(ht, (g(ut), at(() => g(ut).ganado ? "✅" : "❌")))), O(kt, ht) }, $$slots: { default: !0 } }), O(ti, an) }, $$slots: { default: !0 } }) }), O(ke, de) }, $$slots: { default: !0 } }), O(vr, mr) }, $$slots: { default: !0 } }), Nt(() => { At(W, (g(o), at(() => g(o).total))), At(K, `${g(o), at(() => g(o).winrate) ?? ""}%`), At(U, `${g(o), at(() => g(o).lossrate) ?? ""}%`), At(D, (g(o), at(() => g(o).balance))) }), O(m, A) }, b = (m, A) => { { var I = C => { var W = wm(); O(C, W) }, P = C => { var W = ym(); O(C, W) }; dt(m, C => { g(i) ? C(I) : C(P, !1) }, A) } }; dt(S, m => { g(o) ? m(x) : m(b, !1) }) } Nt(() => { w.disabled = g(i), At(_, g(i) ? "Cargando..." : "Actualizar") }), sf("click", w, l), O(e, u), J() } var Sm = rt('<main class="svelte-1b9gt1"><h1>Resumen de Trades</h1> <!></main>'); function Am(e) { typeof window < "u" && document.documentElement.classList.add("dark"); var t = Sm(), r = G(nt(t), 2); xm(r, {}), O(e, t) } Pc(Am, { target: document.getElementById("app") });
